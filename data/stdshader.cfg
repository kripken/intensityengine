// XXX: A workaround version for ATI cards on Windows 7 is here: http://cubeengine.com/forum.php4?action=display_thread&thread_id=2288

// standard shader definitions

fpopts = [
    @(if (= $shaderprecision 0) [result "OPTION ARB_precision_hint_fastest;"])
    @(if (= $shaderprecision 2) [result "OPTION ARB_precision_hint_nicest;"])
]

vpstart = [
    !!ARBvp1.0
    @(if $apple_ff_bug [result [
        ATTRIB opos = vertex.position;
        DP4 result.position.x, state.matrix.mvp.row[0], opos;
        DP4 result.position.y, state.matrix.mvp.row[1], opos;
        DP4 result.position.z, state.matrix.mvp.row[2], opos;
        DP4 result.position.w, state.matrix.mvp.row[3], opos;
    ]] [result [
        OPTION ARB_position_invariant;
        ATTRIB opos = vertex.position; 
    ]])
]

fpstart = [
    !!ARBfp1.0
    @fpopts
]

macro normalize [
    DP3 %1.w, %2, %2;
    RSQ %1.w, %1.w;
    MUL %1.xyz, %1.w, %2;
]

fogcoord = [
    TEMP fogplane;
    MAD fogplane, state.matrix.modelview.row[2], program.env[8].x, program.env[9];
    DP4 result.fogcoord, -opos, fogplane;
]

macro rgbafog [
    TEMP fog;
    SUB fog, state.fog.params.z, fragment.fogcoord.x;
    MUL_SAT fog, fog, state.fog.params.w;
    LRP result.color, fog, %1, %2;
]

lazyshader = [
    defershader $arg1 $arg2 [
        shader @arg1 @arg2 [@@arg3] [@@arg4]
    ]
]

vertexparam0 = "program.env[16]"
vertexparam1 = "program.env[17]"
vertexparam2 = "program.env[18]"
vertexparam3 = "program.env[19]"
vertexparam4 = "program.env[20]"
vertexparam5 = "program.env[21]"
vertexparam6 = "program.env[22]"
vertexparam7 = "program.env[23]"

pixelparam0 = "program.env[16]"
pixelparam1 = "program.env[17]"
pixelparam2 = "program.env[18]"
pixelparam3 = "program.env[19]"
pixelparam4 = "program.env[20]"
pixelparam5 = "program.env[21]"
pixelparam6 = "program.env[22]"
pixelparam7 = "program.env[23]"

///////////////////////////////////////////////////
//
// used for any textured polys that don't have a shader set
//
///////////////////////////////////////////////////

shader 0 "default" [        
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    END
] [
    @fpstart
    TEMP diffuse;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MUL result.color, fragment.color, diffuse;
    END
]

shader 0 "rect" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    END
] [
    @fpstart
    TEMP diffuse;
    TEX diffuse, fragment.texcoord[0], texture[0], RECT;
    MUL result.color, fragment.color, diffuse;
    END
]

shader 0 "rgbonly" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    END
] [
    @fpstart
    TEMP diffuse;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MUL result.color.xyz, fragment.color, diffuse;
    MOV result.color.w, fragment.color;
    END
]

//////////////////////////////////////////////////////////////////////
//
// same, but now without texture sampling (some HUD stuff needs this)
//
//////////////////////////////////////////////////////////////////////

shader 0 "notexture" [        
    @vpstart
    MOV result.color, vertex.color;
    END
] [
    @fpstart
    MOV result.color, fragment.color;
    END
]

//////////////////////////////////////////////////////////////////////
//
// fogged variants of default shaders
//
//////////////////////////////////////////////////////////////////////

shader 0 "fogged" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    @fogcoord
    END 
] [ 
    @fpstart
    OPTION ARB_fog_linear;
    TEMP diffuse;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MUL result.color, fragment.color, diffuse;
    END
]   

shader 0 "foggednotexture" [
    @vpstart
    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    MOV result.color, fragment.color;
    END
]

//////////////////////////////////////////////////////////////////////
//
// for filling the z-buffer only (i.e. multi-pass rendering, OQ)
//
//////////////////////////////////////////////////////////////////////

shader 0 "nocolor" [
    @vpstart
    END
] [
    @fpstart
    END
]

// some OpenGL implementations don't have consistent depth computation between assembly and GLSL shaders
shader 4 "nocolorglsl" [
    void main() { gl_Position = ftransform(); } 
] [
    void main() {}
]

////////////////////////////////////////////////////////
//
// default lightmapped world shader.. does texcoord gen
//
///////////////////////////////////////////////////////

worldshader = [
    shader (if (< (strstr $arg1 "env") 0) 0 2) $arg1 [
        @vpstart
        DP4 result.texcoord[0].x, opos, program.env[0];
        DP4 result.texcoord[0].y, opos, program.env[1];
        DP3 result.texcoord[1].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
        DP3 result.texcoord[1].y, state.matrix.texture[1].row[1], vertex.texcoord[1];

        @arg2

        #pragma CUBE2_shadowmap
        #pragma CUBE2_dynlight
        @fogcoord
        #pragma CUBE2_water

        END
    ] [
        @fpstart
        OPTION ARB_fog_linear;
        TEMP diffuse, lm;
        TEX diffuse, fragment.texcoord[0], texture[0], 2D;
        TEX lm,      fragment.texcoord[1], texture[1], 2D;

        #pragma CUBE2_shadowmap lm
        #pragma CUBE2_dynlight lm

        @arg3

        MUL diffuse.rgb, diffuse, 2;
        @(if (< $numargs 4) [result [MUL result.color, diffuse, lm;]] [result $arg4])

        #pragma CUBE2_water

        END
    ]
]

glareworldshader = [
    variantshader (if (< (strstr $arg1 "env") 0) 0 2) $arg1 4 [
        @vpstart
        DP4 result.texcoord[0].x, opos, program.env[0];
        DP4 result.texcoord[0].y, opos, program.env[1];
        DP3 result.texcoord[1].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
        DP3 result.texcoord[1].y, state.matrix.texture[1].row[1], vertex.texcoord[1];

        @arg2

        @fogcoord

        END
    ] [
        @fpstart
        OPTION ARB_fog_linear;

        @arg3

        END
    ]
]

worldshader "stdworld" [] []

defershader 0 "decalworld" [
  worldshader "decalworld" [] [
    TEMP decal;
    TEX decal, fragment.texcoord[0], texture[2], 2D;
    LRP diffuse, decal.w, decal, diffuse;
  ]
]

defershader 0 "colorworld" [
  defpixelparam "colorscale" 0 1 1 1 // color modulator
  worldshader "colorworld" [] [
    MUL diffuse.rgb, diffuse, @pixelparam0;
  ]
]

defershader 0 "glowworld" [
  defpixelparam "glowcolor" 0 1 1 1 // glow color
  worldshader "glowworld" [] [] [
    TEMP glow;
    TEX glow, fragment.texcoord[0], texture[2], 2D;
    MUL glow, glow, @pixelparam0;
    MAD result.color, lm, diffuse, glow;
  ]
  glareworldshader "glowworld" [] [
    TEMP glow, k;
    TEX glow, fragment.texcoord[0], texture[2], 2D;
    MUL glow, glow, @pixelparam0;
    MAX k, glow.r, glow.g;
    MAX k, k, glow.b;
    MUL k, k, k;
    MUL_SAT k, k, 32;
    MUL result.color, k, glow;
  ]
]

defershader 0 "pulseworld" [
  defvertexparam "pulsespeed" 1 1 // pulse frequency (Hz)
  worldshader "pulseworld" [
    TEMP k;
    MUL k, program.env[6], @vertexparam1.x;
    FRC k, k;
    MAD k, k, 2, -1;
    ABS result.texcoord[2], k;
  ] [
    TEMP pulse;
    TEX pulse, fragment.texcoord[0], texture[2], 2D;
    LRP diffuse, fragment.texcoord[2], pulse, diffuse;
  ]
]

defershader 0 "pulseglowworld" [
  defvertexparam "glowcolor" 0 1 1 1 // glow color
  defvertexparam "pulseglowspeed" 1 1 // pulse frequency (Hz)
  defvertexparam "pulseglowcolor" 2 0 0 0 // pulse glow color
  worldshader "pulseglowworld" [
    TEMP k, col;
    MUL k, program.env[6], @vertexparam1.x;
    FRC k, k;
    MAD k, k, 2, -1;
    ABS k, k;
    SUB col, @vertexparam2, @vertexparam0; 
    MAD result.texcoord[2], k, col, @vertexparam0;
  ] [] [
    TEMP glow;
    TEX glow, fragment.texcoord[0], texture[2], 2D;
    MUL glow, glow, fragment.texcoord[2];
    MAD result.color, lm, diffuse, glow;
  ]
  glareworldshader "pulseglowworld" [
    TEMP k, col;
    MUL k, program.env[6], @vertexparam1.x;
    FRC k, k;
    MAD k, k, 2, -1;
    ABS k, k;
    SUB col, @vertexparam2, @vertexparam0; 
    MAD result.texcoord[2], k, col, @vertexparam0;
  ] [
    TEMP glow, k;
    TEX glow, fragment.texcoord[0], texture[2], 2D;
    MUL glow, glow, fragment.texcoord[2];
    MAX k, glow.r, glow.g;
    MAX k, k, glow.b;
    MUL k, k, k;
    MUL_SAT k, k, 32;
    MUL result.color, k, glow;
    #pragma CUBE2_variant TEX result.color.a, fragment.texcoord[1], texture[1], 2D;
  ]
]

shader 0 "fogworld" [
    @vpstart
    END
] [
    @fpstart
    MOV result.color, state.fog.color;
    END
]

shader 0 "noglareworld" [
    @vpstart
    END
] [
    @fpstart
    MOV result.color, 0;
    END
]

shader 0 "noglareblendworld" [
    @vpstart
    DP3 result.texcoord[0].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
    DP3 result.texcoord[0].y, state.matrix.texture[1].row[1], vertex.texcoord[1];
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    MOV result.color.rgb, 0;
    TEX result.color.a, fragment.texcoord[0], texture[1], 2D;
    END
]
 
defershader 2 "envworld" [
  defpixelparam "envscale" 0 0.2 0.2 0.2 // reflectivity 
  worldshader "envworld" [
    MAD result.texcoord[2], vertex.color, 2, -1;
    SUB result.texcoord[3], program.env[4], opos;
  ] [
    ATTRIB normal = fragment.texcoord[2];
    ATTRIB camvec = fragment.texcoord[3];
    TEMP rvec;
    DP3 rvec, camvec, normal;
    MUL rvec, rvec, normal; 
    MAD rvec, rvec, 2, -camvec; 

    TEMP reflect;
    TEX reflect, rvec, texture[2], CUBE;
  ] [
    MUL diffuse, diffuse, lm;
    LRP result.color.rgb, @pixelparam0, reflect, diffuse;
    MOV result.color.a, diffuse.a;
  ]

  defpixelparam "envscale" 0 0.2 0.2 0.2 // reflectivity 
  worldshader "envworldfast" [
    TEMP camvec, normal, rvec;
    MAD normal, vertex.color, 2, -1;
    SUB camvec, program.env[4], opos;
    DP3 rvec, camvec, normal;
    MUL rvec, rvec, normal; 
    MAD result.texcoord[2], rvec, 2, -camvec; 
  ] [
    TEMP reflect;
    TEX reflect, fragment.texcoord[2], texture[2], CUBE;
  ] [
    MUL diffuse, diffuse, lm;
    LRP result.color.rgb, @pixelparam0, reflect, diffuse;
    MOV result.color.a, diffuse.a;
  ]

  defpixelparam "envscale" 0 0.2 0.2 0.2 // reflectivity 
  worldshader "envworldalt" [] []

  altshader envworld envworldalt
  fastshader envworld envworldfast 2
  fastshader envworld envworldalt 1
]

defershader 0 "gradientworld" [
  defvertexparam "gradientscale" 0 1 // diffuse relative scale
  defvertexparam "gradientdir" 1 1 0 // gradient direction
  shader 0 gradientworld [
    @vpstart

    TEMP tc;
    DP4 tc.x, opos, program.env[0];
    DP4 tc.y, opos, program.env[1];
    MOV result.texcoord[0], tc;
    MUL result.texcoord[2].xy, tc, @vertexparam0.x;
    // geforce 6/7 causes an offset error in the gradient when it is stored along with texcoords
    DP3 @(if $minimizetcusage [result "result.texcoord[2].z"] [result "result.texcoord[3]"]), tc, @vertexparam1; 

    DP3 result.texcoord[1].x, state.matrix.texture[1].row[0], vertex.texcoord[1];
    DP3 result.texcoord[1].y, state.matrix.texture[1].row[1], vertex.texcoord[1];

    #pragma CUBE2_shadowmap
    #pragma CUBE2_dynlight
    @fogcoord
    #pragma CUBE2_water

    END
  ] [
    @fpstart
    OPTION ARB_fog_linear;
    TEMP diffuse, diffuse2, gradient, lm;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    TEX diffuse2, fragment.texcoord[2], texture[2], 2D;
    FRC gradient, @(if $minimizetcusage [result "fragment.texcoord[2].z"] [result "fragment.texcoord[3]"]);
    LRP diffuse, gradient, diffuse, diffuse2;

    TEX lm,      fragment.texcoord[1], texture[1], 2D;

    #pragma CUBE2_shadowmap lm
    #pragma CUBE2_dynlight lm

    MUL diffuse.rgb, diffuse, 2;
    MUL result.color, diffuse, lm;

    #pragma CUBE2_water

    END
  ]
]

shader 0 depthfxworld [
    @vpstart
    TEMP z;
    DP4 z.x, -opos, state.matrix.modelview.row[2];
    MAD result.texcoord[0], z.x, program.env[0], program.env[1];
    END
] [
    @fpstart
    MOV result.color, fragment.texcoord[0];
    END
]

shader 0 depthfxsplitworld [
    @vpstart
    TEMP z;
    DP4 z.x, -opos, state.matrix.modelview.row[2];
    MAD result.texcoord[0], z.x, program.env[0], program.env[1];
    END
] [
    @fpstart
    TEMP ranges;
    MOV ranges.x, fragment.texcoord[0];
    FRC ranges.yzw, fragment.texcoord[0];
    MAD result.color, ranges.yzxw, { -0.00390625, -0.00390625, 0, 0 }, ranges; 
    END
]

// bumptype:
//    e -> reserve envmap texture slot
//    o -> orthonormalize
//    t -> tangent space cam
//    r -> envmap reflection
//    R -> modulate envmap reflection with spec map
//    s -> spec
//    S -> spec map
//    p -> parallax
//    P -> steep parallax (7 steps)
//    g -> glow
//    G -> pulse glow
//    i -> glare intensity

btopt = [ >= (strstr $bumptype $arg1) 0 ]

bumpvariantshader = [
    bumptype = $arg2
    normtex = (if (btopt "e") [result "texture[4]"] [result "texture[3]"])
    glowtex = (if (btopt "e") [result "texture[5]"] [result "texture[4]"])
    stype = (if (btopt "e") [result 3] [result 1])
    if (! (btopt "i")) [
        if (btopt "G") [
            defpixelparam "glowcolor" 0 1 1 1 // glow color
            defvertexparam "pulseglowspeed" 4 1     // pulse frequency (Hz)
            defpixelparam "pulseglowcolor" 5 0 0 0 // pulse glow color
        ] [if (btopt "g") [
            defpixelparam "glowcolor" 0 1 1 1  // glow color
        ]]
        if (btopt "S") [
            defpixelparam "specscale" 1 6 6 6 // spec map multiplier
        ] [if (btopt "s") [
            defpixelparam "specscale" 1 1 1 1 // spec multiplier
        ]]
        if (|| (btopt "p") (btopt "P")) [
            defpixelparam "parallaxscale" 2 0.06 -0.03 // parallax scaling
        ]
        if (btopt "R") [
            defpixelparam "envscale" 3 1 1 1 // reflectivity map multiplier
        ] [if (btopt "r") [
            defpixelparam "envscale" 3 0.2 0.2 0.2 // reflectivity 
        ]]
    ] [
        if (btopt "s") [stype = (+ $stype 8)]
    ]
    variantshader $stype $arg1 (if (btopt "i") [result 4] [result -1]) [
        @vpstart
        DP4 result.texcoord[0].x, opos, program.env[0];
        DP4 result.texcoord[0].y, opos, program.env[1];
        // need to store these in Z/W to keep texcoords < 6, otherwise kills performance on Radeons
        // but slows lightmap access in fragment shader a bit, so avoid when possible
        DP3 @(if (|| $minimizetcusage (btopt "r")) [result "result.texcoord[0].w"] [result "result.texcoord[1].x"]), state.matrix.texture[1].row[0], vertex.texcoord[1];
        DP3 @(if (|| $minimizetcusage (btopt "r")) [result "result.texcoord[0].z"] [result "result.texcoord[1].y"]), state.matrix.texture[1].row[1], vertex.texcoord[1];
        @fogcoord
        
        @(if (btopt "o") [result [
            TEMP camv, normal, tangent, binormal, x, y;
            MAD normal, vertex.color, 2, -1;
        
            // TS gram-schmidt orthonormalization, needed for non-90 degree surfaces (expensive, TS only used for eye vector! can remove if no spec/parallax)
            DP3 x, normal, program.env[2];
            MUL x, x, normal;
            SUB tangent, program.env[2], x;
            DP3 x, tangent, program.env[3];
            MUL x, x, tangent;
            DP3 y, normal, program.env[3];
            MUL y, y, normal;
            SUB binormal, program.env[3], x;
            SUB binormal, binormal, y;
        
            @@(if (btopt "t") [result [
                // trans eye vector into TS
                SUB camv, program.env[4], opos;
                DP3 @(if (btopt "r") [result "result.texcoord[1].x"] [result "result.texcoord[2].x"]), camv, tangent;
                DP3 @(if (btopt "r") [result "result.texcoord[1].y"] [result "result.texcoord[2].y"]), camv, binormal;
                DP3 @(if (btopt "r") [result "result.texcoord[1].z"] [result "result.texcoord[2].z"]), camv, normal;
            ]])
            @@(if (btopt "r") [result [
                @@(if (! (btopt "t")) [result [
                    SUB result.texcoord[1].xyz, program.env[4], opos;
                ]])

                // calculate tangent -> world transform
                MOV result.texcoord[2].x, tangent.x;
                MOV result.texcoord[2].y, binormal.x;
                MOV result.texcoord[2].z, normal.x;

                MOV result.texcoord[3].x, tangent.y;
                MOV result.texcoord[3].y, binormal.y;
                MOV result.texcoord[3].z, normal.y;

                MOV result.texcoord[4].x, tangent.z;
                MOV result.texcoord[4].y, binormal.z;
                MOV result.texcoord[4].z, normal.z;
            ]])
        ]])

        @(if (btopt "G") [result [
            TEMP pulse, pulsecol;
            MUL pulse, program.env[6], @vertexparam4.x;
            FRC pulse, pulse;
            MAD pulse, pulse, 2, -1;
            ABS result.texcoord[1].w, pulse.x;
        ]])

        @(if (|| (! (btopt "i")) (btopt "s")) [result [
            #pragma CUBE2_dynlight
        ]])
        @(if (! (btopt "i")) [result [
            #pragma CUBE2_shadowmap
            #pragma CUBE2_water
        ]])

        END
    ] [
        @fpstart
        OPTION ARB_fog_linear;
        ATTRIB @(if (|| (btopt "p") (btopt "P")) [result "htc"] [result "dtc"]) = fragment.texcoord[0];
        ATTRIB lmtc = @(if (|| $minimizetcusage (btopt "r")) [result "fragment.texcoord[0]"] [result "fragment.texcoord[1]"]);
        @(if (btopt "r") [result [
            ATTRIB cam = fragment.texcoord[1];
        ]] [if (btopt "t") [result [
            ATTRIB cam = fragment.texcoord[2];
        ]]]) 
        TEMP diffuse, lmc, lmlv, bump;

        @(if (|| (! (btopt "i")) (btopt "s")) [result [
            TEX lmc,  @(if (|| $minimizetcusage (btopt "r")) [result "lmtc.wzyx"] [result "lmtc"]), texture[1], 2D;
            MOV result.color.a, lmc;
            TEX lmlv, @(if (|| $minimizetcusage (btopt "r")) [result "lmtc.wzyx"] [result "lmtc"]), texture[2], 2D;
            MAD lmlv, lmlv, 2, -1;    
        ]])

        @(if (btopt "t") [result [
            TEMP camvts;
            @(normalize camvts cam)
        ]])

        @(if (btopt "p") [result [
            TEMP height;
            TEX height, htc, @@normtex, 2D;
            MAD height.w, height.w, @pixelparam2.x, @pixelparam2.y;    
            TEMP dtc;
            MAD dtc, height.w, camvts, htc;
        ]])

        @(if (btopt "P") [result [
            PARAM step = -0.142857142857143; // 1 / 7
            TEMP duv, dtc, cc;
            RCP duv, camvts.z;
            MUL duv, duv, camvts;
            MUL duv, duv, step;
            MUL duv.xy, duv, @pixelparam2.x;

            MAD dtc.xy, duv, @pixelparam2.y, htc;
            MOV dtc.z, 1.0;
            TEX bump, dtc, @@normtex, 2D; 

            @@(loopconcat i 7 [concatword [
                SLT cc, bump.w, dtc.z;
                MAD dtc, duv, cc, dtc;
                TEX bump, dtc, @@normtex, 2D;
            ]])
        ]])

        @(if (|| (! (btopt "i")) (btopt "S")) [result [
            TEX @(if (btopt "i") [result "diffuse.a"] [result "diffuse"]), dtc, texture[0], 2D;
        ]])
        @(if (! (btopt "i")) [result [
            MUL diffuse.rgb, diffuse, 2;
        ]])

        @(if (|| (! (btopt "i")) (btopt "s")) [result [
            @(if (! (btopt "P")) [result [TEX bump, dtc, @normtex, 2D;]])
            MAD bump.xyz, bump, 2, -1;
        ]])

        @(if (btopt "s") [result [
            PARAM specfactor = @(if (btopt "i") 128 32);
            TEMP he;
            ADD he, camvts, lmlv;
            @(normalize he he)
            DP3_SAT he.w, he, bump;
            POW he.w, he.w, specfactor.x;
            @(if (btopt "i") [result [MUL_SAT he.w, he, 64;]])
            @(if (btopt "S") [result [MUL he.w, he, diffuse;]])
            @(if (btopt "i") [result [
                MUL diffuse.rgb, he.w, @pixelparam1;
            ]] [result [
                MAD diffuse.rgb, he.w, @pixelparam1, diffuse;
            ]])
        ]])

        @(if (|| (! (btopt "i")) (btopt "s")) [result [
            DP3_SAT lmlv, bump, lmlv;
            MUL lmc.rgb, lmc, lmlv;
            MAX lmc.rgb, lmc, program.env[5];

            @(if (btopt "i") [result [
                #pragma CUBE2_dynlight lmc

                MUL @(if (btopt "g") [result "diffuse.rgb"] [result "result.color.rgb"]), diffuse, lmc;
            ]] [result [
                #pragma CUBE2_shadowmap lmc
                #pragma CUBE2_dynlight lmc

                MUL @(if (|| (btopt "g") (btopt "r")) [result "diffuse.rgb"] [result "result.color.rgb"]), diffuse, lmc;
            ]])
        ]])

        @(if (btopt "r") [result [
            TEMP rvec;
            @(if (btopt "t") [result [
                TEMP rvects;
                DP3 rvects, cam, bump;
                MUL rvects, rvects, bump; 
                MAD rvects, rvects, 2, -cam; 

                DP3 rvec.x, rvects, fragment.texcoord[2];
                DP3 rvec.y, rvects, fragment.texcoord[3];
                DP3 rvec.z, rvects, fragment.texcoord[4];
            ]] [result [
                TEMP bumpw;
                DP3 bumpw.x, bump, fragment.texcoord[2];
                DP3 bumpw.y, bump, fragment.texcoord[3];
                DP3 bumpw.z, bump, fragment.texcoord[4];

                DP3 rvec, cam, bumpw;
                MUL rvec, rvec, bumpw; 
                MAD rvec, rvec, 2, -cam; 
            ]])

            TEMP reflect;
            TEX reflect, rvec, texture[3], CUBE;
            @@(if (btopt "R") [result [
                TEMP rmod;
                MUL rmod, diffuse.w, @pixelparam3;
            ]] [result [
                PARAM rmod = @pixelparam3;
            ]])
            LRP @(if (btopt "g") [result "diffuse.rgb"] [result "result.color.rgb"]), rmod, reflect, diffuse;
        ]])

        @(if (btopt "g") [result [
            TEMP glow;
            TEX glow, dtc, @@glowtex, 2D;
            @@(if (btopt "G") [result [
                TEMP pulsecol;
                LRP pulsecol, fragment.texcoord[1].w, @pixelparam5, @pixelparam0;
            ]])
            @@(if (btopt "i") [result [
                TEMP k;
                MUL glow, glow, @(if (btopt "G") [result "pulsecol"] [result $pixelparam0]);
                MAX k, glow.r, glow.g;
                MAX k, k, glow.b;
                MUL k, k, k; 
                MUL_SAT k, k, 32; 
                @(if (btopt "s") [result [
                    MAD result.color.rgb, k, glow, diffuse;
                ]] [result [
                    MUL result.color.rgb, k, glow;
                    #pragma CUBE2_variant TEX result.color.a, @(if $minimizetcusage [result "lmtc.wzyx"] [result "lmtc"]), texture[1], 2D;
                ]])
            ]] [result [
                MAD result.color.rgb, glow, @(if (btopt "G") [result "pulsecol"] [result $pixelparam0]), diffuse;
            ]])
        ]])

        @(if (! (btopt "i")) [result [
            #pragma CUBE2_water
        ]])

        END
    ]
]

bumpshader = [
    defershader (if (>= (strstr $arg2 "e") 0) [result 3] [result 1]) $arg1 [
        bumpvariantshader @arg1 @arg2
        if (|| (btopt "g") (btopt "s")) [
            bumpvariantshader @@arg1 (strreplace (concatword @@arg2 "i") "r")
        ]
    ]
]

bumpshader "bumpworld" ""
bumpshader "bumpspecworld" "ots"
fastshader bumpspecworld bumpworld 2
altshader bumpspecworld bumpworld
bumpshader "bumpspecmapworld" "otsS"
fastshader bumpspecmapworld bumpworld 2
altshader bumpspecmapworld bumpworld

bumpshader "bumpglowworld" "g"
bumpshader "bumpspecglowworld" "otsg"
altshader bumpspecglowworld bumpglowworld
bumpshader "bumpspecmapglowworld" "otsSg"
fastshader bumpspecmapglowworld bumpglowworld 2
altshader bumpspecmapglowworld bumpglowworld

bumpshader "bumppulseglowworld" "gG"
bumpshader "bumpspecpulseglowworld" "otsgG"
altshader bumpspecpulseglowworld bumppulseglowworld
bumpshader "bumpspecmappulseglowworld" "otsSgG"
fastshader bumpspecmappulseglowworld bumppulseglowworld 2
altshader bumpspecmappulseglowworld bumppulseglowworld

bumpshader "bumpparallaxworld" "pot"
fastshader bumpparallaxworld bumpworld 1
altshader bumpparallaxworld bumpworld
bumpshader "bumpspecparallaxworld" "pots"
fastshader bumpspecparallaxworld bumpparallaxworld 2
fastshader bumpspecparallaxworld bumpworld 1
altshader bumpspecparallaxworld bumpworld
bumpshader "bumpspecmapparallaxworld" "potsS"
fastshader bumpspecmapparallaxworld bumpparallaxworld 2
fastshader bumpspecmapparallaxworld bumpworld 1
altshader bumpspecmapparallaxworld bumpworld

bumpshader "bumpparallaxglowworld" "potg"
fastshader bumpparallaxglowworld bumpglowworld 1
altshader bumpparallaxglowworld bumpglowworld
bumpshader "bumpspecparallaxglowworld" "potsg"
fastshader bumpspecparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecparallaxglowworld bumpglowworld 1
altshader bumpspecparallaxglowworld bumpglowworld
bumpshader "bumpspecmapparallaxglowworld" "potsSg"
fastshader bumpspecmapparallaxglowworld bumpparallaxglowworld 2
fastshader bumpspecmapparallaxglowworld bumpglowworld 1
altshader bumpspecmapparallaxglowworld bumpglowworld

bumpshader "bumpparallaxpulseglowworld" "potgG"
fastshader bumpparallaxpulseglowworld bumppulseglowworld 1
altshader bumpparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecparallaxpulseglowworld" "potsgG"
fastshader bumpspecparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecparallaxpulseglowworld bumppulseglowworld
bumpshader "bumpspecmapparallaxpulseglowworld" "potsSgG"
fastshader bumpspecmapparallaxpulseglowworld bumpparallaxpulseglowworld 2
fastshader bumpspecmapparallaxpulseglowworld bumppulseglowworld 1
altshader bumpspecmapparallaxpulseglowworld bumppulseglowworld

bumpshader "bumpenvworldalt" "e"
bumpshader "bumpenvworld" "eor"
altshader bumpenvworld bumpenvworldalt
fastshader bumpenvworld bumpenvworldalt 2
bumpshader "bumpenvspecworld" "eotsr"
altshader bumpenvspecworld bumpenvworldalt
fastshader bumpenvspecworld bumpenvworldalt 2
bumpshader "bumpenvspecmapworld" "eotsSrR"
altshader bumpenvspecmapworld bumpenvworldalt
fastshader bumpenvspecmapworld bumpenvworldalt 2

bumpshader "bumpenvglowworldalt" "eg"
bumpshader "bumpenvglowworld" "eorg"
altshader bumpenvglowworld bumpenvglowworldalt
fastshader bumpenvglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecglowworld" "eotsrg"
altshader bumpenvspecglowworld bumpenvglowworldalt
fastshader bumpenvspecglowworld bumpenvglowworldalt 2
bumpshader "bumpenvspecmapglowworld" "eotsSrRg"
altshader bumpenvspecmapglowworld bumpenvglowworldalt
fastshader bumpenvspecmapglowworld bumpenvglowworldalt 2

bumpshader "bumpenvpulseglowworldalt" "egG"
bumpshader "bumpenvpulseglowworld" "eorgG"
altshader bumpenvpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecpulseglowworld" "eotsrgG"
altshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecpulseglowworld bumpenvpulseglowworldalt 2
bumpshader "bumpenvspecmappulseglowworld" "eotsSrRgG"
altshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt
fastshader bumpenvspecmappulseglowworld bumpenvpulseglowworldalt 2

bumpshader "bumpenvparallaxworldalt" "epot"
altshader bumpenvparallaxworldalt bumpenvworldalt
bumpshader "bumpenvparallaxworld" "epotr"
altshader bumpenvparallaxworld bumpenvparallaxworldalt
fastshader bumpenvparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecparallaxworld" "epotsr"
altshader bumpenvspecparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecparallaxworld bumpenvworldalt 1
bumpshader "bumpenvspecmapparallaxworld" "epotsSrR"
altshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt
fastshader bumpenvspecmapparallaxworld bumpenvparallaxworldalt 2
fastshader bumpenvspecmapparallaxworld bumpenvworldalt 1

bumpshader "bumpenvparallaxglowworldalt" "epotg"
altshader bumpenvparallaxglowworldalt bumpenvglowworldalt
bumpshader "bumpenvparallaxglowworld" "epotrg"
altshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecparallaxglowworld" "epotsrg"
altshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecparallaxglowworld bumpenvglowworldalt 1
bumpshader "bumpenvspecmapparallaxglowworld" "epotsSrRg"
altshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt
fastshader bumpenvspecmapparallaxglowworld bumpenvparallaxglowworldalt 2
fastshader bumpenvspecmapparallaxglowworld bumpenvglowworldalt 1

bumpshader "bumpenvparallaxpulseglowworldalt" "epotgG"
altshader bumpenvparallaxpulseglowworldalt bumpenvpulseglowworldalt
bumpshader "bumpenvparallaxpulseglowworld" "epotrgG"
altshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt
fastshader bumpenvparallaxpulseglowworld bumpenvparallaxpulseglowpulseglowworldalt 2
fastshader bumpenvparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecparallaxpulseglowworld" "epotsrgG"
altshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecparallaxpulseglowworld bumpenvpulseglowworldalt 1
bumpshader "bumpenvspecmapparallaxpulseglowworld" "epotsSrRgG"
altshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvparallaxpulseglowworldalt 2
fastshader bumpenvspecmapparallaxpulseglowworld bumpenvpulseglowworldalt 1

//bumpshader "steepworld" "Pot"

////////////////////////////////////////////////
//
// phong lighting model shader
//
////////////////////////////////////////////////

// skeletal animation for matrices and dual quaternions

skelmatanim = [
    result [
        PARAM mats[] = { program.env[ 10 .. @@(- (- $maxvpenvparams $reservevpparams) 1) ] };
        @(if (> $arg1 1) [result "ATTRIB weights = vertex.attrib[6];"])
        ATTRIB bones = vertex.attrib[7]; 
        ADDRESS bone;
        TEMP mx, my, mz;

        ARL bone.x, bones.x;
        @(if (= $arg1 1) [result [
            MOV mx, mats[bone.x];
            MOV my, mats[bone.x+1];
            MOV mz, mats[bone.x+2];
        ]] [result [
            MUL mx, weights.x, mats[bone.x];
            MUL my, weights.x, mats[bone.x+1];
            MUL mz, weights.x, mats[bone.x+2];
            ARL bone.x, bones.y;
            MAD mx, weights.y, mats[bone.x], mx;
            MAD my, weights.y, mats[bone.x+1], my;
            MAD mz, weights.y, mats[bone.x+2], mz;
        ]])
        @(if (>= $arg1 3) [result [
            ARL bone.x, bones.z;
            MAD mx, weights.z, mats[bone.x], mx;
            MAD my, weights.z, mats[bone.x+1], my;
            MAD mz, weights.z, mats[bone.x+2], mz;
        ]])
        @(if (>= $arg1 4) [result [
            ARL bone.x, bones.w;
            MAD mx, weights.w, mats[bone.x], mx;
            MAD my, weights.w, mats[bone.x+1], my;
            MAD mz, weights.w, mats[bone.x+2], mz;
        ]])

        TEMP opos;
        DP4 opos.x, mx, spos;
        DP4 opos.y, my, spos;
        DP4 opos.z, mz, spos;
        MOV opos.w, spos.w;

        @(if $arg2 [result [
            TEMP onormal;
            DP3 onormal.x, mx, snormal;
            DP3 onormal.y, my, snormal;
            DP3 onormal.z, mz, snormal;
        ]])

        @(if $arg3 [result [
            TEMP otangent;
            DP3 otangent.x, mx, stangent;
            DP3 otangent.y, my, stangent;
            DP3 otangent.z, mz, stangent;
        ]])
    ]
]

skelquatanim = [
    result [
        PARAM quats[] = { program.env[ 10 .. @@(- (- $maxvpenvparams $reservevpparams) 1) ] };
        @(if (> $arg1 1) [result "ATTRIB weights = vertex.attrib[6];"])
        ATTRIB bones = vertex.attrib[7]; 
        ADDRESS bone;
        TEMP dqreal, dqdual, dir;
        
        ARL bone.x, bones.x;
        @(if (= $arg1 1) [result [
            MOV dqreal, quats[bone.x];
            MOV dqdual, quats[bone.x+1];
        ]] [result [ 
            MUL dqreal, weights.x, quats[bone.x];
            MUL dqdual, weights.x, quats[bone.x+1];
            ARL bone.x, bones.y;
            MAD dqreal, weights.y, quats[bone.x], dqreal;
            MAD dqdual, weights.y, quats[bone.x+1], dqdual;
            @(if (>= $arg1 3) [result [
                ARL bone.x, bones.z;
                MAD dqreal, weights.z, quats[bone.x], dqreal;
                MAD dqdual, weights.z, quats[bone.x+1], dqdual;
            ]])
            @(if (>= $arg1 4) [result [
                ARL bone.x, bones.w;
                MAD dqreal, weights.w, quats[bone.x], dqreal;
                MAD dqdual, weights.w, quats[bone.x+1], dqdual;
            ]])

            TEMP len;
            DP4 len.x, dqreal, dqreal;
            RSQ len.x, len.x;
            MUL dqreal, dqreal, len.x;
            MUL dqdual, dqdual, len.x;
        ]])

        TEMP opos;    
        XPD opos.xyz, dqreal, spos;
        MAD opos.xyz, spos, dqreal.w, opos;
        ADD opos.xyz, opos, dqdual;
        XPD opos.xyz, dqreal, opos;    
        MAD opos.xyz, dqdual, dqreal.w, opos;
        MAD opos.xyz, dqreal, -dqdual.w, opos;
        MAD opos.xyz, 2, opos, spos;
        MOV opos.w, spos.w;

        @(if $arg2 [result [
            TEMP onormal;
            XPD onormal.xyz, dqreal, snormal;
            MAD onormal.xyz, dqreal.w, snormal, onormal;
            XPD onormal.xyz, dqreal, onormal;
            MAD onormal.xyz, 2, onormal, snormal;
        ]])

        @(if $arg3 [result [
            TEMP otangent;
            XPD otangent.xyz, dqreal, stangent;
            MAD otangent.xyz, dqreal.w, stangent, otangent;
            XPD otangent.xyz, dqreal, otangent;
            MAD otangent.xyz, 2, otangent, stangent;
        ]])
    ]
]

// model shadowmapping

shadowmapcastervertexshader = [
    result [
        @(if (< $numargs 1) [result $vpstart] [result [
            !!ARBvp1.0
            ATTRIB spos = vertex.position;
            @arg1
            DP4 result.position.x, opos, state.matrix.mvp.row[0];
            DP4 result.position.y, opos, state.matrix.mvp.row[1];
            DP4 result.position.w, opos, state.matrix.mvp.row[3];
        ]])

        TEMP z;
        DP4 z.x, opos, state.matrix.mvp.row[2];

        @(if (>= $numargs 1) [result "MOV result.position.z, z.x;"])

        SUB result.texcoord[0].x, 1, z.x;
        MOV result.texcoord[0].y, 1;
        MOV result.texcoord[0].z, 0;
        MOV result.texcoord[0].w, program.env[1].x;

        END
    ]
]

shader 0 shadowmapcaster (shadowmapcastervertexshader) [
    @fpstart
    MOV result.color, fragment.texcoord[0];
    END
]
loop i 4 [
    variantshader 0 shadowmapcaster 0 (shadowmapcastervertexshader (skelmatanim (+ $i 1) 0 0)) []
    variantshader 0 shadowmapcaster 1 (shadowmapcastervertexshader (skelquatanim (+ $i 1) 0 0)) []
]        

shader 0 "shadowmapreceiver" [
    @vpstart
    TEMP z;
    DP4 z, state.matrix.mvp.row[2], opos;
    @(if $ati_minmax_bug [result [
        MOV result.texcoord[0].xyw, 0;
        SUB result.texcoord[0].z, program.env[0].y, z;
    ]] [result [
        SUB result.texcoord[0], program.env[0].y, z;
    ]])
    END
] [
    @fpstart
    MOV result.color, fragment.texcoord[0];
    END
]

// model stencil shadows

notexturemodelvertexshader = [
    result [
        @(if (< $numargs 1) [result $vpstart] [result [
            !!ARBvp1.0
            ATTRIB spos = vertex.position;
            @arg1
            DP4 result.position.x, opos, state.matrix.mvp.row[0];
            DP4 result.position.y, opos, state.matrix.mvp.row[1];
            DP4 result.position.z, opos, state.matrix.mvp.row[2];
            DP4 result.position.w, opos, state.matrix.mvp.row[3];
        ]])

        MOV result.color, vertex.color;
        @fogcoord
        END
    ]
]

shader 0 notexturemodel (notexturemodelvertexshader) [
    @fpstart
    OPTION ARB_fog_linear;
    MOV result.color, fragment.color;
    END
]
loop i 4 [
    variantshader 0 notexturemodel 0 (notexturemodelvertexshader (skelmatanim (+ $i 1) 0 0)) []
    variantshader 0 notexturemodel 1 (notexturemodelvertexshader (skelquatanim (+ $i 1) 0 0)) []
]

// mdltype:
//    e -> envmap
//    n -> normalmap
//    s -> spec
//    m -> masks
//    B -> matrix skeletal animation
//    b -> dual-quat skeletal animation
//    i -> glare intensity

mdlopt = [ >= (strstr $modeltype $arg1) 0 ]

modelvertexshader = [
    modeltype = $arg1
    result [
        @(if (|| (mdlopt "b") (mdlopt "B")) [result [
            !!ARBvp1.0
            ATTRIB spos = vertex.position;
            ATTRIB snormal = vertex.normal;
            @(if (mdlopt "n") [result "ATTRIB stangent = vertex.attrib[1];"])
        ]] [result [
            @vpstart
            ATTRIB onormal = vertex.normal;
            @(if (mdlopt "n") [result "ATTRIB otangent = vertex.attrib[1];"])
        ]])
        PARAM ocampos = program.env[1];
        PARAM lightdir = program.env[0];
        PARAM lightscale = program.env[2];

        @(if (mdlopt "B") [skelmatanim $arg2 1 (mdlopt "n")])
        @(if (mdlopt "b") [skelquatanim $arg2 1 (mdlopt "n")])
        @(if (|| (mdlopt "b") (mdlopt "B")) [result [
            DP4 result.position.x, opos, state.matrix.mvp.row[0];
            DP4 result.position.y, opos, state.matrix.mvp.row[1];
            DP4 result.position.z, opos, state.matrix.mvp.row[2];
            DP4 result.position.w, opos, state.matrix.mvp.row[3];
        ]])

        MOV result.color, vertex.color;
        MOV result.texcoord[0], vertex.texcoord[0];
      
        @(if (|| (mdlopt "e") (mdlopt "s")) [result [
            TEMP camvec;
            SUB camvec, ocampos, opos;
            @(normalize camvec camvec)
        ]])

        @(if (mdlopt "n") [result [
            TEMP obitangent;
            XPD obitangent, onormal, otangent;
            @(normalize obitangent obitangent)
            MUL obitangent, obitangent, @(if (|| (mdlopt "b") (mdlopt "B")) [result "stangent.w"] [result "otangent.w"]);

            DP3 result.texcoord[1].x, lightdir, otangent;
            DP3 result.texcoord[1].y, lightdir, obitangent;
            DP3 result.texcoord[1].z, lightdir, onormal;

            @(if (mdlopt "e") [result [
                DP3 result.texcoord[2].x, camvec, otangent;
                DP3 result.texcoord[2].y, camvec, obitangent;
                DP3 result.texcoord[2].z, camvec, onormal;

                // composition of tangent -> object and object -> world transforms
                //   becomes tangent -> world
                DP3 result.texcoord[3].x, state.matrix.texture.row[0], otangent;
                DP3 result.texcoord[3].y, state.matrix.texture.row[0], obitangent;
                DP3 result.texcoord[3].z, state.matrix.texture.row[0], onormal;

                DP3 result.texcoord[4].x, state.matrix.texture.row[1], otangent;
                DP3 result.texcoord[4].y, state.matrix.texture.row[1], obitangent;
                DP3 result.texcoord[4].z, state.matrix.texture.row[1], onormal;

                DP3 result.texcoord[5].x, state.matrix.texture.row[2], otangent;
                DP3 result.texcoord[5].y, state.matrix.texture.row[2], obitangent;
                DP3 result.texcoord[5].z, state.matrix.texture.row[2], onormal;
            ]] [if (mdlopt "s") [result [
                TEMP halfangle;
                ADD halfangle, lightdir, camvec;
                DP3 result.texcoord[2].x, halfangle, otangent;
                DP3 result.texcoord[2].y, halfangle, obitangent;
                DP3 result.texcoord[2].z, halfangle, onormal;
            ]]])
        ]] [result [
            @(if (mdlopt "s") [result [
                MOV result.texcoord[1], onormal;
                MOV result.texcoord[2], lightdir; 
                ADD result.texcoord[3], lightdir, camvec;
            ]] [result [
                TEMP light;
                DP3 light.x, onormal, lightdir;
                ADD light.x, light.x, 0.5;
                MAX light.x, light.x, lightscale.y;
                MUL result.texcoord[1].xyz, light.x, vertex.color;
                MOV result.texcoord[1].w, vertex.color.w;
            ]])
            @(if (mdlopt "e") [result [
                TEMP rvec, invfresnel;
                DP3 invfresnel, camvec, onormal;
                MUL rvec, invfresnel, onormal; 
                MAD rvec, rvec, 2, -camvec;
                DP3 result.texcoord[4].x, state.matrix.texture.row[0], rvec;
                DP3 result.texcoord[4].y, state.matrix.texture.row[1], rvec;
                DP3 result.texcoord[4].z, state.matrix.texture.row[2], rvec;
                MAX invfresnel, invfresnel, 0;
                MAD result.texcoord[4].w, program.env[3].x, invfresnel, program.env[3].y;
            ]])
        ]])

        @fogcoord

        END
    ] 
]

modelfragmentshader = [
    modeltype = $arg1
    result [
        @fpstart
        OPTION ARB_fog_linear;
        ATTRIB dtc = fragment.texcoord[0];
        @(if (mdlopt "n") [result "ATTRIB lightdir = fragment.texcoord[1];"])
        @(if (! (|| (|| (mdlopt "n") (mdlopt "s")) (mdlopt "i"))) [result "ATTRIB color = fragment.texcoord[1];"])
        @(if (mdlopt "s") [result [
            @(if (&& (! (mdlopt "n")) (! (mdlopt "i"))) [result [
                ATTRIB lightdir = fragment.texcoord[2];
            ]])
            PARAM specfactor = @(if (mdlopt "i") 256 128);
        ]])
        @(if (|| (|| (mdlopt "s") (mdlopt "m")) (&& (mdlopt "n") (! (mdlopt "i")))) [result "PARAM lightscale = program.env[2];"])
        TEMP diffuse, light;

        TEX diffuse, dtc, texture[0], 2D;

        @(if (mdlopt "n") [result [
            TEMP normal;
            TEX normal, dtc, texture[3], 2D;
            //MAD normal, normal, 2, -1;
            SUB normal, normal, 0.5;
            @(normalize normal normal)
        ]])

        @(if (mdlopt "s") [result [
            TEMP spec, halfangle;
            @(if (mdlopt "n") [
                if (mdlopt "e") [result [
                    ADD halfangle, lightdir, fragment.texcoord[2];
                    @(normalize halfangle halfangle)
                ]] [result [
                    @(normalize halfangle fragment.texcoord[2])
                ]]
            ] [result [
                TEMP normal;
                @(normalize halfangle fragment.texcoord[3])
                @(normalize normal fragment.texcoord[1])
            ]])
            DP3_SAT spec.x, halfangle, normal;
            POW spec.x, spec.x, specfactor.x;
            MUL spec.x, spec.x, lightscale.x;
        ]])

        @(if (&& (|| (mdlopt "s") (mdlopt "n")) (! (mdlopt "i"))) [result [
            DP3 light.x, normal, lightdir;
            ADD light.x, light.x, 0.5;
            MAX light.x, light.x, lightscale.y;
        ]])

        @(if (mdlopt "m") [result [
            TEMP masks;
            TEX masks, dtc, texture[1], 2D;
                
            @(if (mdlopt "s") [result "MUL spec.x, spec.x, masks.r;"])   // specmap in red channel
        ]])
        
        @(if (mdlopt "i") [
            if (mdlopt "s") [result [
                MUL spec.x, spec.x, program.env[4].x;
                MUL @(if (mdlopt "m") [result "light.rgb"] [result "result.color.rgb"]), spec.x, fragment.color;
            ]] [
                if (! (mdlopt "m")) [result "MOV result.color.rgb, 0;"]
            ]
        ] [
            if (mdlopt "s") [result [
                MAD light.rgb, light.x, diffuse, spec.x;
                MUL @(if (mdlopt "m") [result "light.rgb"] [result "result.color.rgb"]), light, fragment.color; 
            ]] [if (mdlopt "n") [result [
                MUL light.rgb, light.x, diffuse;
                MUL @(if (mdlopt "m") [result "light.rgb"] [result "result.color.rgb"]), light, fragment.color;
            ]] [result [
                MUL @(if (mdlopt "m") [result "light.rgb"] [result "result.color"]), color, diffuse;
            ]]]
        ])

        @(if (mdlopt "m") [result [
            TEMP glow;
            MUL glow.rgb, diffuse, lightscale.z;

            @(if (mdlopt "e") [result [
                LRP light.rgb, masks.g, glow, light;

                TEMP reflect;
                @(if (mdlopt "n") [result [
                    TEMP camvec, invfresnel, rvects, rvec;
                    @(normalize camvec fragment.texcoord[2])
                    DP3 invfresnel, camvec, normal;
                    MUL rvects, invfresnel, normal; 
                    MAD rvects, rvects, 2, -camvec; 

                    DP3 rvec.x, rvects, fragment.texcoord[3];
                    DP3 rvec.y, rvects, fragment.texcoord[4];
                    DP3 rvec.z, rvects, fragment.texcoord[5];

                    MAX invfresnel, invfresnel, 0;
                    MAD invfresnel, program.env[3].x, invfresnel, program.env[3].y;

                    TEX reflect, rvec, texture[2], CUBE;
                    MUL masks.b, masks.b, invfresnel; // envmap mask in blue channel
                ]] [result [
                    TEX reflect, fragment.texcoord[4], texture[2], CUBE;
                    MUL masks.b, masks.b, fragment.texcoord[4].w; // envmap mask in blue channel
                ]])
                LRP result.color.rgb, masks.b, reflect, light;
            ]] [if (mdlopt "i") [result [
                TEMP k;
                MUL k.x, masks.g, masks.g;
                MUL_SAT k.x, k.x, program.env[4].y;
                @(if (mdlopt "s") [result [
                    MAD result.color.rgb, k.x, glow, light;
                ]] [result [
                    MUL result.color.rgb, k.x, glow;
                ]])
            ]] [result [
                LRP result.color.rgb, masks.g, glow, light;
            ]]])
        ]])

        @(if (|| (|| (mdlopt "s") (mdlopt "n")) (mdlopt "i")) [result [
            MUL result.color.a, diffuse.a, fragment.color.a;
        ]] [if (mdlopt "m") [result [
            MUL result.color.a, color.a, diffuse.a;
        ]]])

        END
    ]
]

modelshader = [
    defershader 0 $arg1 [
        basemodeltype = [@@arg2]
        shader 0 @arg1 (modelvertexshader $basemodeltype) (modelfragmentshader $basemodeltype)
        loop i 4 [
            variantshader 0 @@arg1 0 (modelvertexshader (concatword "B" $basemodeltype) (+ $i 1)) []
            variantshader 0 @@arg1 1 (modelvertexshader (concatword "b" $basemodeltype) (+ $i 1)) []
        ]
        glaremodeltype = (strreplace (concatword $basemodeltype "i") "e") 
        if (< (strstr $glaremodeltype "s") 0) [glaremodeltype = (strreplace $glaremodeltype "n")]
        variantshader 0 @arg1 2 (modelvertexshader $glaremodeltype) (modelfragmentshader $glaremodeltype)
        loop i 4 [
            variantshader 0 @@arg1 2 (modelvertexshader (concatword "B" $glaremodeltype) (+ $i 1)) 2
            variantshader 0 @@arg1 3 (modelvertexshader (concatword "b" $glaremodeltype) (+ $i 1)) 2
        ]
    ]
]

////////////////////////////////////////////////
//
// gourad lighting model shader: cheaper, non-specular version for vegetation etc. gets used when spec==0
//
////////////////////////////////////////////////

modelshader "nospecmodel" ""
modelshader "masksnospecmodel" "m"
modelshader "envmapnospecmodel" "me"
altshader envmapnospecmodel masksnospecmodel

modelshader "bumpnospecmodel" "n"
modelshader "bumpmasksnospecmodel" "nm"
modelshader "bumpenvmapnospecmodel" "nme"
altshader bumpenvmapnospecmodel bumpmasksnospecmodel

////////////////////////////////////////////////
//
// phong lighting model shader
//
////////////////////////////////////////////////

modelshader "stdmodel" "s"
fastshader stdmodel nospecmodel 1
modelshader "masksmodel" "sm"
fastshader masksmodel masksnospecmodel 1
modelshader "envmapmodel" "sme"
altshader envmapmodel masksmodel
fastshader envmapmodel envmapnospecmodel 1

modelshader "bumpmodel" "ns"
fastshader bumpmodel bumpnospecmodel 1
modelshader "bumpmasksmodel" "nsm"
fastshader bumpmasksmodel bumpmasksnospecmodel 1
modelshader "bumpenvmapmodel" "nsme"
altshader bumpenvmapmodel bumpmasksmodel
fastshader bumpenvmapmodel bumpenvmapnospecmodel 1

////////////////////////////////////////////////
//
// separable blur with up to 7 taps
//
////////////////////////////////////////////////

blurshader = [
    shader 0 $arg1 [
        !!ARBvp1.0
        MOV result.position, vertex.position;
        MOV result.texcoord[0], vertex.texcoord[0];
        TEMP tc1, tc2;
        MAD tc1, program.env[1], { 1, 1, 0, 0 }, vertex.texcoord[0];
        MAD tc2, program.env[1], { -1, -1, 0, 0 }, vertex.texcoord[0];
        MOV result.texcoord[1], tc1;
        MOV result.texcoord[2], tc2;
        @(loopconcat i (min (- $arg2 1) 2) [concatword [
            ADD tc1.@@arg3, tc1, program.env[1].@(at "z w" $i);
            SUB tc2.@@arg3, tc2, program.env[1].@(at "z w" $i);
            MOV result.texcoord[@@(+ (* $i 2) 3)], tc1;
            MOV result.texcoord[@@(+ (* $i 2) 4)], tc2;
        ]])
        END
    ] [
        @fpstart
        TEMP val, blur1, blur2;
        TEX val, fragment.texcoord[0], texture[0], @arg4;
        MUL val, val, program.env[0].x;
        @(if (> $arg2 3) [result [
            TEMP tc1, tc2;
        ]])
        @(loopconcat i $arg2 [concatword [
            @(if (< $i 3) [result [
                TEX blur1, fragment.texcoord[@@(+ (* $i 2) 1)], texture[0], @@@arg4;
                TEX blur2, fragment.texcoord[@@(+ (* $i 2) 2)], texture[0], @@@arg4;
            ]] [result [
                ADD tc1, fragment.texcoord[0], program.env[@@@(+ $i 0)];
                SUB tc2, fragment.texcoord[0], program.env[@@@(+ $i 0)];
                TEX blur1, tc1, texture[0], @@@arg4;
                TEX blur2, tc2, texture[0], @@@arg4;
            ]])
            ADD blur1, blur1, blur2;
            @(if (< $i 3) [result [
                MAD @(if (= (+ $i 1) $arg2) [result "result.color"] [result "val"]), blur1, program.env[0].@(at "y z w" $i), val;
            ]] [result [
                MAD @(if (= (+ $i 1) $arg2) [result "result.color"] [result "val"]), blur1, program.env[2].@(at "x y z w" (- $i 3)), val;
            ]])
        ]])
        END
    ]
]

loop i 7 [
    blurshader (format "blurx%1" (+ $i 1)) (+ $i 1) x 2D
    blurshader (format "blury%1" (+ $i 1)) (+ $i 1) y 2D
    if (> $i 0) [
        altshader (format "blurx%1" (+ $i 1)) (format "blurx%1" $i)
        altshader (format "blury%1" (+ $i 1)) (format "blury%1" $i)
    ]
    if $usetexrect [
        blurshader (format "blurx%1rect" (+ $i 1)) (+ $i 1) x RECT
        blurshader (format "blury%1rect" (+ $i 1)) (+ $i 1) y RECT
        if (> $i 0) [
            altshader (format "blurx%1rect" (+ $i 1)) (format "blurx%1rect" $i)
            altshader (format "blury%1rect" (+ $i 1)) (format "blury%1rect" $i)
        ]
    ]
]

////////////////////////////////////////////////
//
// full screen shaders: 
//
////////////////////////////////////////////////

fsvs = [
    !!ARBvp1.0
    MOV result.position, vertex.position;   // woohoo, no mvp :) 
    MOV result.texcoord[0], vertex.texcoord[0];
]

fsps = [
    @fpstart
    TEMP sample;
    TEX sample, fragment.texcoord[0], texture[0], RECT;
]

setup4corners = [
    ADD result.texcoord[1], vertex.texcoord[0], { -1.5, -1.5, 0, 0 };        
    ADD result.texcoord[2], vertex.texcoord[0], {  1.5, -1.5, 0, 0 };        
    ADD result.texcoord[3], vertex.texcoord[0], { -1.5,  1.5, 0, 0 };        
    ADD result.texcoord[4], vertex.texcoord[0], {  1.5,  1.5, 0, 0 };        
]

sample4corners = [
    TEMP s00, s02, s20, s22;
    TEX s00, fragment.texcoord[1], texture[0], RECT;
    TEX s02, fragment.texcoord[2], texture[0], RECT;
    TEX s20, fragment.texcoord[3], texture[0], RECT;
    TEX s22, fragment.texcoord[4], texture[0], RECT;
]

// some simple ones that just do an effect on the RGB value...

lazyshader 0 "invert" [ @fsvs END ] [ @fsps SUB result.color, 1, sample;   END ]
lazyshader 0 "gbr"    [ @fsvs END ] [ @fsps MOV result.color, sample.yzxw; END ]
lazyshader 0 "bw"     [ @fsvs END ] [ @fsps DP3 result.color, sample, 0.333; END ]

// sobel

lazyshader 0 "sobel" [ @fsvs @setup4corners END ] [
    @fsps
    @sample4corners

    TEMP t, u;

    ADD t, s00, s20;
    SUB t, t, s02;
    SUB t, t, s22;
    MUL t, t, t;

    ADD u, s00, s02;
    SUB u, u, s20;
    SUB u, u, s22;
    MUL u, u, u;

    ADD t, t, u;

    ADD result.color, sample, t;
    END
]

// rotoscope

lazyshader 0 "rotoscope" [
    @fsvs
    PARAM scale = program.env[0];
    // stuff two sets of texture coordinates into each one to get around hardware attribute limits
    MAD result.texcoord[1], { -1.0, -1.0,  1.0, 0.0 }, scale.x, vertex.texcoord[0].xyyx;
    MAD result.texcoord[2], { -1.0,  0.0, -1.0, 1.0 }, scale.x, vertex.texcoord[0].xyyx;
    MAD result.texcoord[3], { -1.0,  1.0,  0.0, 1.0 }, scale.x, vertex.texcoord[0].xyyx;
    MAD result.texcoord[4], {  0.0, -1.0,  1.0, 1.0 }, scale.x, vertex.texcoord[0].xyyx;
    END
] [
    @fpstart
    ATTRIB t11 = fragment.texcoord[0];
    ATTRIB t00_12 = fragment.texcoord[1];
    ATTRIB t01_20 = fragment.texcoord[2];
    ATTRIB t02_21 = fragment.texcoord[3];
    ATTRIB t10_22 = fragment.texcoord[4];
    TEMP c00, c01, c02, c10, c11, c12, c20, c21, c22;

    TEX c00, t00_12, texture[0], RECT;
    TEX c01, t01_20, texture[0], RECT;
    TEX c02, t02_21, texture[0], RECT;
    TEX c10, t10_22, texture[0], RECT;
    TEX c11, t11, texture[0], RECT;
    TEX c12, t00_12.wzyx, texture[0], RECT;
    TEX c20, t01_20.wzyx, texture[0], RECT;
    TEX c21, t02_21.wzyx, texture[0], RECT;
    TEX c22, t10_22.wzyx, texture[0], RECT;

    TEMP diag1, diag2, xedge, yedge;
    SUB diag1, c00, c22;
    SUB diag2, c02, c20;
    SUB xedge, c01, c21;
    MAD xedge, xedge, 2.0, diag1;
    ADD xedge, xedge, diag2;
    SUB yedge, c10, c12;
    MAD yedge, yedge, 2.0, diag1;
    SUB yedge, yedge, diag2;
    MUL xedge, xedge, xedge;
    MUL yedge, yedge, yedge;

    TEMP sobel;
    ADD sobel, xedge, yedge;
    MAX sobel.x, sobel.x, sobel.y;
    MAX sobel.x, sobel.x, sobel.z;
    SLT sobel.x, sobel.x, 0.1;

    TEMP hue;
    DP3 hue.x, c11, 1; 
    RCP hue.w, hue.x;
    MUL c11, c11, hue.w;
    SGE hue.xyz, hue.x, { 0.2, 0.8, 1.5, 0.0 };
    DP3 hue.x, hue, { 0.5, 0.5, 1.5, 0.0 };
    MUL c11, c11, hue.x;

    MAX sobel.x, sobel.x, hue.z;
    MUL result.color, c11, sobel.x;

    END
]

blur3shader = [
    lazyshader 0 $arg1 [ 
        !!ARBvp1.0
        MOV result.position, vertex.position;
        ADD result.texcoord[0], vertex.texcoord[0], { @(if $arg2 -0.5 0), @(if $arg3 -0.5 0), 0, 0 };
        ADD result.texcoord[1], vertex.texcoord[0], { @(if $arg2 0.5 0), @(if $arg3 0.5 0), 0, 0 };
        END 
    ] [
        @fpstart
        TEMP c1, c2;
        TEX c1, fragment.texcoord[0], texture[0], RECT;
        TEX c2, fragment.texcoord[1], texture[0], RECT;
        ADD c1, c1, c2;
        MUL result.color, c1, 0.5;
        END
    ]
]
blur3shader hblur3 1 0
blur3shader vblur3 0 1

blur5shader = [
    lazyshader 0 $arg1 [ 
        @fsvs 
        ADD result.texcoord[1], vertex.texcoord[0], { @(if $arg2 -1.333 0), @(if $arg3 -1.333 0), 0, 0 };
        ADD result.texcoord[2], vertex.texcoord[0], { @(if $arg2 1.333 0), @(if $arg2 1.333 0), 0, 0 };
        END 
    ] [
        @fpstart
        TEMP c0, c1, c2;
        TEX c0, fragment.texcoord[0], texture[0], RECT;
        TEX c1, fragment.texcoord[1], texture[0], RECT;
        TEX c2, fragment.texcoord[2], texture[0], RECT;
        ADD c1, c1, c2;
        MUL c0, c0, 0.4;
        MAD result.color, c1, 0.3, c0;
        END
    ]
]
blur5shader hblur5 1 0
blur5shader vblur5 0 1

rotoscope = [
    clearpostfx
    if (>= $numargs 1) [addpostfx rotoscope 0 0 0 $arg1]
    if (>= $numargs 2) [
        if (= $arg2 1) [addpostfx hblur3; addpostfx vblur3]
        if (= $arg2 2) [addpostfx hblur5; addpostfx vblur5]
    ]
]

// bloom-ish

shader 0 "glare" [
    !!ARBvp1.0
    MOV result.position, vertex.position;
    MOV result.texcoord[0], vertex.texcoord[0];
    END
] [
    @fpstart
    TEMP glare;
    TEX glare, fragment.texcoord[0], texture[0], 2D;
    MUL result.color, glare, program.env[0];
    END
]

lazyshader 0 "bloom_scale" [ @fsvs @setup4corners END ] [
    @fsps
    @sample4corners
    TEMP t;
    ADD t, s02, s00;
    ADD t, t, s22;
    ADD t, t, s20;
    ADD t, t, sample;
    MUL result.color, t, 0.2; 
    END
]

lazyshader 0 "bloom_init" [ @fsvs END ] [
    @fsps
    TEMP t;
    MAX t, sample.r, sample.g;
    MAX t, t, sample.b;
    MUL t, t, t;
    MUL result.color, t, sample;
    END
]

bloomshader = [
  defershader 0 $arg1 [
    forceshader "bloom_scale"
    forceshader "bloom_init"
    shader 0 @arg1 [
        @fsvs
        TEMP tc;
        MOV tc, vertex.texcoord[0];
        @@(loopconcat i $arg2 [concat "MUL tc, tc, 0.5; MOV result.texcoord[" (+ $i 1) "], tc;"])
        END
    ] [
        @fsps
        TEMP scaled, bloom;
        @@(loopconcat i $arg2 [
            format [
                TEX @(if (> $i 0) [result "scaled"] [result "bloom"]), fragment.texcoord[%1], texture[%1], RECT;
                @(if (> $i 0) [result [
                    ADD bloom, bloom, scaled;
                ]])
            ] (+ $i 1)
        ])
        MAD result.color, bloom, program.env[0].x, sample;
        END
    ]
  ]
]

bloomshader bloom1 1
bloomshader bloom2 2
bloomshader bloom3 3
bloomshader bloom4 4
bloomshader bloom5 5
bloomshader bloom6 6

setupbloom = [
    addpostfx bloom_init 1 1 "+0"
    loop i (- $arg1 1) [
        addpostfx bloom_scale (+ $i 2) (+ $i 2) (concatword "+" (+ $i 1))
    ]
    addpostfx (concatword bloom $arg1) 0 0 (loopconcat i (+ $arg1 1) [result $i]) $arg2
]

bloom = [
    clearpostfx
    if (>= $numargs 1) [setupbloom 6 $arg1]
]

////////////////////////////////////////////////
//
// miscellaneous effect shaders: 
//
////////////////////////////////////////////////

// wobbles the vertices of an explosion sphere
// and generates all texcoords 
// and blends the edge color
// and modulates the texture
explosionshader = [
    shader 0 $arg1 [
        !!ARBvp1.0
        ATTRIB opos = vertex.position; 
        OUTPUT spos = result.position;
        
        TEMP wobble; // uses a simple linear oscillation instead of more expensive sinusoidal
        DP3 wobble, opos, program.env[0]; // generate wobble offset based off vertex normal and sphere center
        MAD wobble, program.env[1].w, 0.002, wobble; // wobble frequency
        FRC wobble, wobble; // 0..1
        SUB wobble, wobble, 0.5; // -0.5..0.5
        ABS wobble, wobble; // now oscillates up and down between 0..0.5
        MUL wobble, wobble, 0.5; // wobble amplitude
        
        MAD wobble.xyz, wobble, opos, opos;
        MOV wobble.w, opos.w;
        
        @(if (>= (strstr $arg1 "soft") 0) [result [
            TEMP projtc;
            DP4 projtc.x, state.matrix.mvp.row[0], wobble; 
            DP4 projtc.y, state.matrix.mvp.row[1], wobble; 
            DP4 projtc.z, state.matrix.mvp.row[2], wobble; 
            DP4 projtc.w, state.matrix.mvp.row[3], wobble;
            MOV spos, projtc;

            DP4 projtc.z, state.matrix.modelview.row[2], -wobble; 
            MAD projtc.z, projtc, program.env[5].x, program.env[5].y;
            ADD projtc.xy, projtc, projtc.w;
            MUL projtc.xy, projtc, program.env[6];
            MOV result.texcoord[3], projtc;
        ]] [result [
            DP4 spos.x, state.matrix.mvp.row[0], wobble; 
            DP4 spos.y, state.matrix.mvp.row[1], wobble; 
            DP4 spos.z, state.matrix.mvp.row[2], wobble; 
            DP4 spos.w, state.matrix.mvp.row[3], wobble;
        ]])

        MOV result.color, vertex.color;

        @arg2 
        
        @fogcoord
        END
    ] [ 
        @fpstart
        OPTION ARB_fog_linear;
        TEMP dtc, diffuse, blend, tint;
        
        TEX dtc, @arg3, texture[0], 2D;
        MAD dtc, dtc, 0.1, fragment.texcoord[0]; // use color texture as noise to distort texcoords
        TEX diffuse, dtc, texture[0], 2D;
        
        TEX blend, fragment.texcoord[1], texture[1], 2D; // get blend factors from modulation texture 

        @(if (>= (strstr $arg1 "glare") 0) [result [
            TEMP k;
            MUL k, blend.a, blend.a;
            MUL tint, k, { 0, 0, 1, 0 }; 
            MUL tint.b, tint, tint;
            MUL k.rgb, k, 8;
            MAD diffuse, diffuse, k, tint;
        ]] [result [
            MAD tint, blend.a, { 0, 0, -0.5, 0 }, { 0, 0, 0.5, 0 }; // blue tint 
            MUL blend, blend.a, 4; // dup alpha into RGB channels + intensify and over saturate
            MAD diffuse, diffuse, blend, tint;
        ]])

        @(if (>= (strstr $arg1 "soft") 0) [result [
            MUL result.color.rgb, diffuse, fragment.color;

            TEMP depth;
            TXP depth, fragment.texcoord[3], texture[2], @(if (>= (strstr $arg1 "rect") 0) [result "RECT"] [result "2D"]);
            @(if (>= (strstr $arg1 "soft8") 0) [result [
                DP4 depth.x, depth, program.env[6]; 
                SUB_SAT depth.x, depth.x, fragment.texcoord[3].z;
            ]] [result [
                MAD_SAT depth.x, depth.x, program.env[5].z, -fragment.texcoord[3].z;
            ]])
            MUL depth.x, depth.x, fragment.color.a;
            MAX depth.x, depth.x, program.env[5].w;
            MUL result.color.a, diffuse.a, depth.x;
        ]] [result [
            MUL result.color, diffuse, fragment.color;
        ]])

        END
    ]
]

loop i (if $usetexrect 6 4) [
    explosionshader (concatword "explosion2d" (at ["" "glare" "soft" "soft8" "softrect" "soft8rect"] $i)) [
        TEMP dtc; //blow up the tex coords
        MAD dtc, program.env[1].x, -1.414, 1.768; // -2, 2.5; -> -2*sqrt(0.5), 2.5*sqrt(0.5);
        MUL dtc, dtc, dtc;
        MUL dtc, opos, dtc;
        //MAD dtc, dtc, 0.5, 0.5; centering at 0.5 not really needed for color sample since texture isn't clamped, so can just fold in the multiplication as above
        MAD result.texcoord[0], program.env[1].w, 0.0004, dtc;
        MAD result.texcoord[1], opos, 0.5, 0.5; //using wobble makes it look too spherical at a distance
    ] "fragment.texcoord[1]"
    explosionshader (concatword "explosion3d" (at ["" "glare" "soft" "soft8" "softrect" "soft8rect"] $i)) [
        MOV result.texcoord[0], vertex.texcoord[0];

        TEMP texgen;
        DP4 texgen.x, opos, program.env[2];
        DP4 texgen.y, opos, program.env[3];
        MOV result.texcoord[1], texgen;
        MAD result.texcoord[2], program.env[1].w, -0.0005, texgen;
    ] "fragment.texcoord[2]"
]

shader 0 "particlenotexture" [
    @vpstart
    MUL result.texcoord[0], vertex.color, program.env[4];
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    MOV result.color, fragment.texcoord[0];
    END
]

particleshader = [
    shader 0 $arg1 [
        @vpstart
        MOV result.texcoord[0], vertex.texcoord[0];
        MUL result.texcoord[1], vertex.color, program.env[4];

        @(if (>= (strstr $arg1 "soft") 0) [result [
            TEMP projtc;
            DP4 projtc.x, state.matrix.mvp.row[0], opos;
            DP4 projtc.y, state.matrix.mvp.row[1], opos;
            DP4 projtc.w, state.matrix.mvp.row[3], opos;

            ADD projtc.xy, projtc, projtc.w;
            MUL projtc.xy, projtc, program.env[6];
            MOV result.texcoord[2].xyw, projtc;

            TEMP offset;
            MAD offset.xyz, vertex.texcoord[0], { 2.82842712474619, 2.82842712474619, 0, 0 }, { -1.4142135623731, -1.4142135623731, 1, 0 };
            MOV result.texcoord[3].xyz, offset;

            DP4 offset.z, state.matrix.modelview.row[2], -opos;
            MAD offset.z, offset.z, program.env[5].x, program.env[5].y;
            MOV result.texcoord[4].xyz, offset;
        ]])

        @fogcoord
        END
    ] [
        @fpstart
        OPTION ARB_fog_linear;
        TEMP diffuse;
        TEX diffuse, fragment.texcoord[0], texture[0], 2D;
        @(if (>= (strstr $arg1 "soft") 0) [result [
            TEMP depth, offset;
            TXP depth, fragment.texcoord[2], texture[2], @(if (>= (strstr $arg1 "rect") 0) [result "RECT"] [result "2D"]);
            DP3 offset.x, fragment.texcoord[3], fragment.texcoord[4];
            @(if (>= (strstr $arg1 "soft8") 0) [result [
                DP4 depth.x, depth, program.env[6];
                SUB_SAT depth.x, depth.x, offset.x;
            ]] [result [
                MAD_SAT depth.x, depth.x, program.env[5].z, -offset.x;
            ]])
            MUL diffuse.a, diffuse.a, depth.x;
        ]])
        MUL result.color, fragment.texcoord[1], diffuse;
        END
    ]     
]

loop i (if $usetexrect 5 3) [
    particleshader (concatword "particle" (at ["" "soft" "soft8" "softrect" "soft8rect"] $i))
]

shader 0 "blendbrush" [
    @vpstart
    DP4 result.texcoord[0].x, opos, program.env[0];
    DP4 result.texcoord[0].y, opos, program.env[1];
    MOV result.color, vertex.color;
    END
] [
    @fpstart
    TEMP brush;
    TEX brush, fragment.texcoord[0], texture[0], 2D;
    MUL result.color, fragment.color, brush;
    END
]

lazyshader 0 "moviergb" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    END
] [
    @fpstart
    TEX result.color, fragment.texcoord[0], texture[0], RECT;
    END
]

lazyshader 0 "movieyuv" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    END
] [
    @fpstart
    TEMP sample;
    TEX sample, fragment.texcoord[0], texture[0], RECT;
    DP3 result.color.b, sample, { 0.299, 0.587, 0.114, 0 };
    DP4 result.color.g, sample, { -0.169, -0.331, 0.500, 0.500 };
    DP4 result.color.r, sample, { 0.500, -0.419, -0.081, 0.500 };
    END
]

lazyshader 0 "moviey" [
    @vpstart
    ADD result.texcoord[0], vertex.texcoord[0], { -1.5, 0, 0, 0 };
    ADD result.texcoord[1], vertex.texcoord[0], { -0.5, 0, 0, 0 };
    ADD result.texcoord[2], vertex.texcoord[0], {  0.5, 0, 0, 0 };
    ADD result.texcoord[3], vertex.texcoord[0], {  1.5, 0, 0, 0 };
    END
] [
    @fpstart
    TEMP sample1, sample2, sample3, sample4;
    TEX sample1, fragment.texcoord[0], texture[0], RECT;
    TEX sample2, fragment.texcoord[1], texture[0], RECT;
    TEX sample3, fragment.texcoord[2], texture[0], RECT;
    TEX sample4, fragment.texcoord[3], texture[0], RECT;
    DP3 result.color.b, sample1, { 0.299, 0.587, 0.114, 0 };
    DP3 result.color.g, sample2, { 0.299, 0.587, 0.114, 0 };
    DP3 result.color.r, sample3, { 0.299, 0.587, 0.114, 0 };
    DP3 result.color.a, sample4, { 0.299, 0.587, 0.114, 0 };
    END
]

lazyshader 0 "movieu" [
    @vpstart
    ADD result.texcoord[0], vertex.texcoord[0], { -3, 0, 0, 0 };
    ADD result.texcoord[1], vertex.texcoord[0], { -1, 0, 0, 0 };
    ADD result.texcoord[2], vertex.texcoord[0], {  1, 0, 0, 0 };
    ADD result.texcoord[3], vertex.texcoord[0], {  3, 0, 0, 0 };
    END
] [
    @fpstart
    TEMP sample1, sample2, sample3, sample4;
    TEX sample1, fragment.texcoord[0], texture[0], RECT;
    TEX sample2, fragment.texcoord[1], texture[0], RECT;
    TEX sample3, fragment.texcoord[2], texture[0], RECT;
    TEX sample4, fragment.texcoord[3], texture[0], RECT;
    DP4 result.color.b, sample1, { -0.169, -0.331, 0.500, 0.500 };
    DP4 result.color.g, sample2, { -0.169, -0.331, 0.500, 0.500 };
    DP4 result.color.r, sample3, { -0.169, -0.331, 0.500, 0.500 };
    DP4 result.color.a, sample4, { -0.169, -0.331, 0.500, 0.500 };
    END
]

lazyshader 0 "moviev" [
    @vpstart
    ADD result.texcoord[0], vertex.texcoord[0], { -3, 0, 0, 0 };
    ADD result.texcoord[1], vertex.texcoord[0], { -1, 0, 0, 0 };
    ADD result.texcoord[2], vertex.texcoord[0], {  1, 0, 0, 0 };
    ADD result.texcoord[3], vertex.texcoord[0], {  3, 0, 0, 0 };
    END
] [
    @fpstart
    TEMP sample1, sample2, sample3, sample4;
    TEX sample1, fragment.texcoord[0], texture[0], RECT;
    TEX sample2, fragment.texcoord[1], texture[0], RECT;
    TEX sample3, fragment.texcoord[2], texture[0], RECT;
    TEX sample4, fragment.texcoord[3], texture[0], RECT;
    DP4 result.color.b, sample1, { 0.500, -0.419, -0.081, 0.500 };
    DP4 result.color.g, sample2, { 0.500, -0.419, -0.081, 0.500 };
    DP4 result.color.r, sample3, { 0.500, -0.419, -0.081, 0.500 };
    DP4 result.color.a, sample4, { 0.500, -0.419, -0.081, 0.500 };
    END
]

///////////////////////////////////////////////////
//
// reflective/refractive water shaders:
//
///////////////////////////////////////////////////

watershader = [
    spec = $arg2
    rgbfog = $arg3
    distort = $arg4
    combine = $arg5
    lazyshader 1 $arg1 [
        @vpstart
        TEMP tc;
        PARAM campos = program.env[0];
        PARAM seconds = program.env[1];
        @(if $spec [result "PARAM lightpos = program.env[2];"])

        DP4 result.texcoord[0].x, state.matrix.texture.row[0], opos;
        DP4 result.texcoord[0].y, state.matrix.texture.row[1], opos;
        @(if (>= (strstr $arg1 "underwater") 0) [result [
            SUB result.texcoord[0].z, program.env[7], opos.z;
        ]] [result [
            SUB result.texcoord[0].z, opos.z, program.env[7]; 
        ]])
        DP4 result.texcoord[0].w, state.matrix.texture.row[3], opos;
        MUL tc, vertex.texcoord[0], 0.1;
        MAD result.texcoord[1], seconds, 0.04, tc;
        MAD result.texcoord[2], seconds, -0.02, tc;
        SUB result.texcoord[3], campos, opos;
        @(if $spec [result "SUB result.texcoord[4], lightpos, opos;"])

        MOV result.color, vertex.color;

        @fogcoord

        END
    ] [
        @fpstart
        @(if $rgbfog [result "OPTION ARB_fog_linear;"])
        TEMP he, light, cam, bump, invfresnel, temp, dudv;

        ATTRIB projtc = fragment.texcoord[0];
        ATTRIB tc1 = fragment.texcoord[1];
        ATTRIB tc2 = fragment.texcoord[2];
        ATTRIB camts = fragment.texcoord[3];
        @(if $spec [result "ATTRIB lightts = fragment.texcoord[4];"])

        @(normalize cam camts)
        @(if $spec [result [
            @(normalize light lightts)
            ADD he, cam, light;
            @(normalize he he)
        ]])

        TEX dudv, tc1, texture[2], 2D;
        MAD dudv.xy, dudv, 2, -1;

        @distort

        @(if $spec [result [
            PARAM specfactor = 96;

            DP3_SAT he, he, bump;
            POW he, he.x, specfactor.w;
    
            MUL light, program.env[4], light.w;
            RCP_SAT light, light.x;
            MAD light, light, -program.env[3], program.env[3];
        ]])

        @combine

        END
    ]
]

reflectivity = [MAD invfresnel, invfresnel, 0.5, 0.5;]

watershader "waterglare" 1 1 [
    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    MUL he, he, he;
    MUL he, he, 32;
    MUL result.color, he, light;
]

lazyshader 1 "underwater" [
    @vpstart
    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    TEMP col;
    MUL col.rgb, fragment.color, program.env[5].x;
    MUL col.rgb, col, 0.8;
    MUL col.a, 0.5, program.env[5].y;
    @(rgbafog col "{0, 0, 0, 1}")
    END
]

watershader "underwaterrefract" 0 1 [
    MAD temp, dudv, 0.025, tc2;
    TEX dudv, temp, texture[2], 2D;
    MAD dudv.xy, dudv, 2, -1;

    RCP temp.w, projtc.w;
    MUL temp.xy, projtc, temp.w; 
    MAD temp.xy, dudv, 0.01, temp;

    TEX result.color, temp, texture[3], 2D;
] []
watershader "underwaterrefractfast" 0 1 [
    MAD temp, dudv, 0.4, projtc;
    TXP result.color, temp, texture[3], 2D;
] []
fastshader underwaterrefract underwaterrefractfast 2
altshader underwaterrefract underwaterrefractfast

watershader "underwaterfade" 0 1 [
    MAD temp, dudv, 0.025, tc2;
    TEX dudv, temp, texture[2], 2D;
    MAD dudv.xy, dudv, 2, -1;

    RCP temp.w, projtc.w;
    MUL temp.xy, projtc, temp.w; 

    TEMP fade;
    TEX fade.a, temp, texture[3], 2D;
    MOV_SAT fade.r, fragment.position.z;
    MAD fade.a, fade, 4, projtc.z;
    MUL result.color.a, fade.a, fade.r;

    MAD temp.xy, dudv, 0.01, temp;
    TEX result.color.rgb, temp, texture[3], 2D;
] []
watershader "underwaterfadefast" 0 1 [
    MAD temp, dudv, 0.4, projtc;
    TXP result.color.rgb, temp, texture[3], 2D;

    TEMP fade;
    TXP fade.a, projtc, texture[3], 2D;
    MAD result.color.a, fade, 4, projtc.z;
] []
fastshader underwaterfade underwaterfadefast 2
altshader underwaterfade underwaterfadefast

watershader "water" 1 0 [
    MAD temp, dudv, 0.025, tc2; 
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    TEMP diffuse;
    MUL temp, fragment.color, program.env[5].x;
    MUL diffuse, temp, 0.6;
    DP3_SAT invfresnel, cam, bump;
    @reflectivity
    LRP temp, invfresnel, temp, diffuse;

    TEMP col;
    MAD col.rgb, he, light, temp; 
    MUL col.a, invfresnel, program.env[5].y;
    @(rgbafog col "{0, 0, 0, 1}")
]
watershader "waterfast" 0 0 [
    MAD temp, dudv, 0.025, tc2; 
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [    
    TEMP diffuse;
    MUL temp, fragment.color, program.env[5].x;
    MUL diffuse, temp, 0.6;
    DP3_SAT invfresnel, cam, bump;
    @reflectivity

    TEMP col;
    LRP col.rgb, invfresnel, temp, diffuse;
    MUL col.a, invfresnel, program.env[5].y;
    @(rgbafog col "{0, 0, 0, 1}")
]
fastshader water waterfast 1
altshader water waterfast

watershader "waterreflect" 1 0 [
    TEMP reflect;

    MAD temp, dudv, 0.4, projtc;
    TXP reflect, temp, texture[0], 2D;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    DP3_SAT invfresnel, cam, bump;
    @reflectivity
    MUL temp, fragment.color, program.env[5].x;
    LRP temp, invfresnel, temp, reflect;

    TEMP col;
    MAD col.rgb, he, light, temp;
    MUL col.a, invfresnel, program.env[5].y;
    @(rgbafog col "{0, 0, 0, 1}")
]
watershader "waterreflectfast" 0 0 [
    TEMP reflect;

    MAD temp, dudv, 0.4, projtc;
    TXP reflect, temp, texture[0], 2D;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    DP3_SAT invfresnel, cam, bump;
    @reflectivity
    MUL temp, fragment.color, program.env[5].x;

    TEMP col;
    LRP col.rgb, invfresnel, temp, reflect;
    MUL col.a, invfresnel, program.env[5].y;
    @(rgbafog col "{0, 0, 0, 1}")
]
fastshader waterreflect waterreflectfast 2
altshader waterreflect waterreflectfast

watershader "waterrefract" 1 1 [
    TEMP reflect, refract;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
    TEX dudv, temp, texture[2], 2D;
    MAD dudv.xy, dudv, 2, -1;

    RCP temp.w, projtc.w;
    MUL temp.xy, projtc, temp.w; 
    MAD temp.xy, dudv, 0.01, temp;

    TEX reflect, temp, texture[0], 2D;
    TEX refract, temp, texture[3], 2D;
] [
    DP3_SAT invfresnel, cam, bump;
    @reflectivity
    LRP temp, invfresnel, refract, reflect;
    MAD result.color, he, light, temp;
]
watershader "waterrefractfast" 0 1 [
    TEMP reflect, refract;

    MAD temp, dudv, 0.4, projtc;
    TXP reflect, temp, texture[0], 2D;
    TXP refract, temp, texture[3], 2D;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [
    DP3_SAT invfresnel, cam, bump;
    @reflectivity
    LRP result.color, invfresnel, refract, reflect;
]
fastshader waterrefract waterrefractfast 2
altshader waterrefract waterrefractfast

watershader "waterfade" 1 1 [
    TEMP distort, reflect, refract, fade;
    
    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
    TEX dudv, temp, texture[2], 2D;
    MAD dudv.xy, dudv, 2, -1;
    
    RCP temp.w, projtc.w;
    MUL temp.xy, projtc, temp.w; 
    MAD distort.xy, dudv, 0.01, temp;

    TEX reflect, distort, texture[0], 2D;
    TEX refract, distort, texture[3], 2D;
    TEX fade.a, temp, texture[3], 2D;
    MOV_SAT fade.r, fragment.position.z;
    MAD fade.a, fade, 4, projtc.z;
    MUL result.color.a, fade.a, fade.r;
] [
    DP3_SAT invfresnel, cam, bump;
    @reflectivity
    LRP temp, invfresnel, refract, reflect;
    MAD result.color.rgb, he, light, temp;
]   
watershader "waterfadefast" 0 1 [
    TEMP reflect, refract, fade;
    
    MAD temp, dudv, 0.4, projtc;
    TXP reflect, temp, texture[0], 2D;
    TXP refract, temp, texture[3], 2D;
    TXP fade.a, projtc, texture[3], 2D;
    MAD result.color.a, fade, 4, projtc.z;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
] [ 
    DP3_SAT invfresnel, cam, bump;
    @reflectivity
    LRP result.color.rgb, invfresnel, refract, reflect;
]
fastshader waterfade waterfadefast 2
altshader waterfade waterrefract

watershader "waterenv" 1 0 [
    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;

    TEMP rvec, reflect;
    DP3_SAT invfresnel, cam, bump;
    MUL rvec, invfresnel, bump;
    MAD rvec, rvec, 2, -cam;
    TEX reflect, rvec, texture[0], CUBE;
] [
    @reflectivity
    MUL temp, fragment.color, program.env[5].x;
    LRP temp, invfresnel, temp, reflect;

    TEMP col;
    MAD col.rgb, he, light, temp;
    MUL col.a, invfresnel, program.env[5].y;
    @(rgbafog col "{0, 0, 0, 1}")
]
watershader "waterenvfast" 0 0 [
    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;

    TEMP rvec, reflect;
    DP3_SAT invfresnel, cam, bump;
    MUL rvec, invfresnel, bump;
    MAD rvec, rvec, 2, -cam;
    TEX reflect, rvec, texture[0], CUBE;
] [
    @reflectivity
    MUL temp, fragment.color, program.env[5].x;

    TEMP col;
    LRP col.rgb, invfresnel, temp, reflect;
    MUL col.a, invfresnel, program.env[5].y;
    @(rgbafog col "{0, 0, 0, 1}")
]
fastshader waterenv waterenvfast 2
altshader waterenv waterenvfast

watershader "waterenvrefract" 1 1 [
    TEMP distort, reflect, refract;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
    TEX dudv, temp, texture[2], 2D;
    MAD dudv.xy, dudv, 2, -1;

    RCP temp.w, projtc.w;
    MUL temp.xy, projtc, temp.w; 
    MAD distort.xy, dudv, 0.01, temp;

    TEX refract, distort, texture[3], 2D;

    TEMP rvec;
    DP3_SAT invfresnel, cam, bump;
    MUL rvec, invfresnel, bump;
    MAD rvec, rvec, 2, -cam;
    TEX reflect, rvec, texture[0], CUBE;
] [
    @reflectivity
    LRP temp, invfresnel, refract, reflect;
    MAD result.color.rgb, he, light, temp;
]
watershader "waterenvrefractfast" 0 1 [
    TEMP reflect, refract;

    MAD temp, dudv, 0.4, projtc;
    TXP refract, temp, texture[3], 2D;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;

    TEMP rvec;
    DP3_SAT invfresnel, cam, bump;
    MUL rvec, invfresnel, bump;
    MAD rvec, rvec, 2, -cam;
    TEX reflect, rvec, texture[0], CUBE;
] [
    @reflectivity
    LRP result.color.rgb, invfresnel, refract, reflect;
]
fastshader waterenvrefract waterenvrefractfast 2
altshader waterenvrefract waterenvrefractfast

watershader "waterenvfade" 1 1 [
    TEMP distort, reflect, refract, fade;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;
    TEX dudv, temp, texture[2], 2D;
    MAD dudv.xy, dudv, 2, -1;

    RCP temp.w, projtc.w;
    MUL temp.xy, projtc, temp.w; 
    MAD distort.xy, dudv, 0.01, temp;

    TEX refract, distort, texture[3], 2D;
    TEX fade.a, temp, texture[3], 2D;
    MAD result.color.a, fade, 4, projtc.z;

    TEMP rvec;
    DP3_SAT invfresnel, cam, bump;
    MUL rvec, invfresnel, bump;
    MAD rvec, rvec, 2, -cam;
    TEX reflect, rvec, texture[0], CUBE;
] [
    @reflectivity
    LRP temp, invfresnel, refract, reflect;
    MAD result.color.rgb, he, light, temp;
]
watershader "waterenvfadefast" 0 1 [
    TEMP reflect, refract, fade;

    MAD temp, dudv, 0.4, projtc;
    TXP refract, temp, texture[3], 2D;
    TXP fade.a, projtc, texture[3], 2D;
    MAD result.color.a, fade, 4, projtc.z;

    MAD temp, dudv, 0.025, tc2;
    TEX bump, temp, texture[1], 2D;
    MAD bump.xyz, bump, 2, -1;

    TEMP rvec;
    DP3_SAT invfresnel, cam, bump;
    MUL rvec, invfresnel, bump;
    MAD rvec, rvec, 2, -cam;
    TEX reflect, rvec, texture[0], CUBE;
] [
    @reflectivity
    LRP result.color.rgb, invfresnel, refract, reflect;
]
fastshader waterenvfade waterenvfadefast 2
altshader waterenvfade waterenvrefract

causticshader = [
    lazyshader 0 $arg1 [
        @vpstart
        DP3 result.texcoord[0].x, opos, program.env[0];
        DP3 result.texcoord[0].y, opos, program.env[1];
        @fogcoord
        END
    ] [
        @fpstart
        OPTION ARB_fog_linear;
        @arg2
        END
    ]
]
causticshader caustic [
    TEMP caustic, caustic2;
    TEX caustic, fragment.texcoord[0], texture[0], 2D;
    TEX caustic2, fragment.texcoord[0], texture[1], 2D;
    MUL caustic, caustic, program.env[0].x;
    MAD result.color, caustic2, program.env[0].y, caustic;
]
causticshader causticfast [
  TEMP caustic;
  TEX caustic, fragment.texcoord[0], texture[0], 2D;
  MUL result.color, caustic, program.env[0].z;
]
fastshader caustic causticfast 2

lazyshader 0 "lava" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    TEMP diffuse;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MUL diffuse, diffuse, 2;
    MUL result.color, fragment.color, diffuse;
    END
]

lazyshader 0 "lavaglare" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MAD result.color, vertex.color, 2, -1;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    TEMP glow, k;
    TEX glow, fragment.texcoord[0], texture[0], 2D;
    MUL glow, glow, fragment.color;
    MAX k, glow.r, glow.g;
    MAX k, k, glow.b;
    MUL k, k, k;
    MUL k, k, 32;
    MUL result.color, k, glow;
    END
]

lazyshader 0 "waterfallrefract" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    DP4 result.texcoord[1].x, state.matrix.texture.row[0], opos;
    DP4 result.texcoord[1].y, state.matrix.texture.row[1], opos;
    DP4 result.texcoord[1].w, state.matrix.texture.row[3], opos;

    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;

    TEMP diffuse, dudv;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MAD dudv, diffuse, 0.2, fragment.texcoord[0];
    ADD dudv, dudv, program.env[1];
    TEX dudv, dudv, texture[2], 2D;

    TEMP projtc, refract;
    MAD projtc, dudv, { 4, 4, 0, 0 }, fragment.texcoord[1];
    TXP refract, projtc, texture[4], 2D;

    LRP result.color, diffuse, fragment.color, refract;

    END
]

lazyshader 0 "waterfallenvrefract" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    SUB result.texcoord[1], program.env[0], vertex.position;

    TEMP absnormal;
    ABS absnormal, vertex.normal;

    MOV result.texcoord[2].x, absnormal.y;
    MOV result.texcoord[2].y, -absnormal.z;
    MOV result.texcoord[2].z, vertex.normal.x;

    MOV result.texcoord[3].x, absnormal.z;
    MOV result.texcoord[3].y, -absnormal.x;
    MOV result.texcoord[3].z, vertex.normal.y;

    MOV result.texcoord[4].x, absnormal.x;
    MOV result.texcoord[4].y, -absnormal.y;
    MOV result.texcoord[4].z, vertex.normal.z;

    DP4 result.texcoord[5].x, state.matrix.texture.row[0], opos;
    DP4 result.texcoord[5].y, state.matrix.texture.row[1], opos;
    DP4 result.texcoord[5].w, state.matrix.texture.row[3], opos;

    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;

    TEMP diffuse, dudv;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MAD dudv, diffuse, 0.2, fragment.texcoord[0];
    ADD dudv, dudv, program.env[1];
    TEX dudv, dudv, texture[2], 2D;

    TEMP ntc, normal, wnormal;
    MAD ntc, dudv, 0.1, fragment.texcoord[0];
    TEX normal, ntc, texture[1], 2D;
    MAD normal, normal, 2, -1;
    DP3 wnormal.x, normal, fragment.texcoord[2];
    DP3 wnormal.y, normal, fragment.texcoord[3];
    DP3 wnormal.z, normal, fragment.texcoord[4];

    TEMP projtc, refract;
    MAD projtc, dudv, { 4, 4, 0, 0 }, fragment.texcoord[5];
    TXP refract, projtc, texture[4], 2D;

    TEMP cam, invfresnel, rvec, reflect;
    @(normalize cam fragment.texcoord[1])
    DP3 invfresnel, wnormal, cam;
    MUL rvec, invfresnel, wnormal;
    MAD rvec, rvec, 2, -cam;
    TEX reflect, rvec, texture[3], CUBE;
    CMP invfresnel, invfresnel, 1, 0;
    MAD_SAT invfresnel, invfresnel, 0.4, 0.6;
    LRP refract, invfresnel, refract, reflect;
    LRP result.color, diffuse, fragment.color, refract;

    END
]
altshader waterfallenvrefract waterfallrefract

lazyshader 0 "waterfallenv" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    SUB result.texcoord[1], program.env[0], vertex.position;
    
    TEMP absnormal;
    ABS absnormal, vertex.normal;

    MOV result.texcoord[2].x, absnormal.y;
    MOV result.texcoord[2].y, -absnormal.z;
    MOV result.texcoord[2].z, vertex.normal.x;

    MOV result.texcoord[3].x, absnormal.z;
    MOV result.texcoord[3].y, -absnormal.x;
    MOV result.texcoord[3].z, vertex.normal.y;

    MOV result.texcoord[4].x, absnormal.x;
    MOV result.texcoord[4].y, -absnormal.y;
    MOV result.texcoord[4].z, vertex.normal.z;

    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;

    TEMP diffuse, dudv;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MAD dudv, diffuse, 0.2, fragment.texcoord[0];
    ADD dudv, dudv, program.env[1];
    TEX dudv, dudv, texture[2], 2D;
    MAD dudv, dudv, 0.1, fragment.texcoord[0];

    TEMP normal, wnormal;
    TEX normal, dudv, texture[1], 2D;
    MAD normal, normal, 2, -1;
    DP3 wnormal.x, normal, fragment.texcoord[2];
    DP3 wnormal.y, normal, fragment.texcoord[3];
    DP3 wnormal.z, normal, fragment.texcoord[4];

    TEMP cam, rvec, reflect;
    @(normalize cam fragment.texcoord[1])
    DP3 rvec, wnormal, cam;
    MUL rvec, rvec, wnormal;
    MAD rvec, rvec, 2, -cam;
    TEX reflect, rvec, texture[3], CUBE;
    MAD result.color.a, diffuse.r, 0.75, 0.25;
    LRP result.color.rgb, diffuse, fragment.color, reflect;

    END
]

lazyshader 0 "glass" [
    @vpstart
    PARAM campos = program.env[0];
    ATTRIB normal = vertex.normal;
    MOV result.texcoord[0], vertex.texcoord[0];
    SUB result.texcoord[1], campos, opos;
    MOV result.texcoord[2], normal;
    MOV result.color, vertex.color;
    @fogcoord
    END 
] [ 
    @fpstart
    ATTRIB rvec = fragment.texcoord[0];
    ATTRIB camvec = fragment.texcoord[1];
    ATTRIB normal = fragment.texcoord[2];

    TEMP reflect;
    TEX reflect, rvec, texture[0], CUBE;
    
    TEMP invfresnel;
    @(normalize invfresnel camvec)
    DP3 invfresnel, invfresnel, normal;
    MAX invfresnel, invfresnel, 0.70;

    TEMP col;
    MUL col, fragment.color, 0.05;
    LRP col.rgb, invfresnel, col, reflect;
    MUL col.a, invfresnel, 0.95;
 
    @(rgbafog col "{0, 0, 0, 1}")
    END
]
lazyshader 0 "glassfast" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    @fogcoord
    END 
] [ 
    @fpstart
    ATTRIB rvec = fragment.texcoord[0];

    TEMP reflect;
    TEX reflect, rvec, texture[0], CUBE;
    
    PARAM invfresnel = 0.75;
    TEMP col;
    MUL col, fragment.color, 0.05;
    LRP col.rgb, invfresnel, col, reflect;
    MUL col.a, invfresnel, 0.95;

    @(rgbafog col "{0, 0, 0, 1}")
    END
]
fastshader glass glassfast 2
altshader glass glassfast

lazyshader 0 "grass" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.texcoord[1], vertex.texcoord[1];
    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    TEMP diffuse, lm;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    TEX lm, fragment.texcoord[1], texture[1], 2D;
    MUL diffuse.xyz, diffuse, 2;
    MUL diffuse, diffuse, fragment.color;
    MUL result.color, diffuse, lm;
    END
]

shader 0 "overbrightdecal" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    TEMP diffuse;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    LRP result.color, fragment.color.a, diffuse, fragment.color;
    END
]

shader 0 "saturatedecal" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    MOV result.color, vertex.color;
    @fogcoord
    END
] [
    @fpstart
    OPTION ARB_fog_linear;
    TEMP diffuse;
    TEX diffuse, fragment.texcoord[0], texture[0], 2D;
    MUL diffuse.xyz, diffuse, 2;
    MUL result.color, fragment.color, diffuse;
    END
]

shader 0 "skyboxglare" [
    @vpstart
    MOV result.texcoord[0], vertex.texcoord[0];
    END
] [
    @fpstart
    TEMP glare;
    TEX glare, fragment.texcoord[0], texture[0], 2D;
    //DP3 intensity, glare, { 0.33, 0.34, 0.33 };
    //SUB_SAT intensity, intensity, 0.95;
    //MUL intensity, intensity, 32;
    //MUL glare, glare, intensity;
    // ^ all folded into single dot product below
    DP4 result.color, glare, { 10.56, 10.88, 10.56, -30.4 }; 
    END
]

defershader 5 "glsltest" [
  defuniformparam bumpscale 0.06 -0.03
  shader 5 glsltest [
    uniform vec4 texgenS, texgenT, camera, orienttangent, orientbinormal, fogselect, fogplane;
    varying vec3 camvts;
    void main(void)
    {
        gl_Position = ftransform();
        gl_TexCoord[0].st = vec2(dot(gl_Vertex.xyz, texgenS.xyz), dot(gl_Vertex.xyz, texgenT.xyz));
        gl_TexCoord[1].st = vec4(gl_TextureMatrix[1] * gl_MultiTexCoord1).st;
        vec4 wfogplane = vec4(gl_ModelViewMatrix[0].z, gl_ModelViewMatrix[1].z, gl_ModelViewMatrix[2].z, gl_ModelViewMatrix[3].z) * fogselect.x + fogplane;
        gl_FogFragCoord = dot(-gl_Vertex, wfogplane);

        vec3 x, y, tangent, binormal, camv;
        vec3 normal = gl_Color.xyz * 2.0 - 1.0;

        x = dot(normal, orienttangent.xyz) * normal;
        tangent = orienttangent.xyz - x;
        x = dot(tangent, orientbinormal.xyz) * tangent;   
        y = dot(normal, orientbinormal.xyz) * normal;
        binormal = (orientbinormal.xyz - x) - y;
               
        camv = camera.xyz - gl_Vertex.xyz;                
        camvts = vec3(dot(camv, tangent), dot(camv, binormal), dot(camv, normal));

        #pragma CUBE2_shadowmap
        #pragma CUBE2_dynlight
        #pragma CUBE2_water
    }
  ] [
    varying vec3 camvts;
    uniform vec4 ambient, bumpscale;
    uniform sampler2D diffusemap, lmcolor, lmdir, normalmap;
    void main(void)
    {
        vec4 lmc = texture2D(lmcolor, gl_TexCoord[1].st);
        vec3 lmlv = texture2D(lmdir, gl_TexCoord[1].st).xyz * 2.0 - 1.0;
        vec3 camn = normalize(camvts);

        float steps = mix(5.0, 20.0, camn.z);
        float dh = 1.0 / steps;
        vec2 duv = -camn.xy*bumpscale.x / (camn.z*steps);
        float height = 1.0;

        vec2 dtc = gl_TexCoord[0].st + duv*bumpscale.y;
        vec4 bump = texture2D(normalmap, dtc);

        while(bump.w < height)
        {
            height -= dh;
            dtc += duv;
            bump = texture2D(normalmap, dtc);
        }

        vec4 diffuse = texture2D(diffusemap, dtc);
        diffuse.rgb *= 2.0;
        vec3 normal = bump.xyz * 2.0 - 1.0;
        
        float intensity = dot(normal, lmlv);
        if(intensity > 0.0)
        {
            steps = mix(10.0, 20.0, lmlv.z);
            dh = 1.0 / steps;
            duv = lmlv.xy*bumpscale.x / (lmlv.z*steps);

            height = bump.w + dh*0.1;
            while(bump.w < height && height < 1.0)
            {
                height += dh;
                dtc += duv;
                bump = texture2D(normalmap, dtc);
            }

            if(bump.w >= height) intensity = 0.0; 
        }

        lmc.rgb *= clamp(intensity, 0.0, 1.0);
        #pragma CUBE2_shadowmap lmc
        #pragma CUBE2_dynlight lmc
        lmc.rgb = max(lmc.rgb, ambient.rgb);
        gl_FragColor = diffuse * lmc;
        float fog = (gl_Fog.end - gl_FogFragCoord) * gl_Fog.scale;
        gl_FragColor.rgb = mix(vec3(gl_Fog.color), gl_FragColor.rgb, clamp(fog, 0.0, 1.0));
        #pragma CUBE2_water
    }
  ]
]


